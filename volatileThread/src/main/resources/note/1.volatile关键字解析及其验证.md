# Volatile 关键字

在多线程程的领域中， volatile 关键字也是非常重要的。Volatile 在使用上具有以下特性

## 1.可见性：

B 线程能马上看到 A 线程更改的数据

先来看一个死循环的例子

创建 VolatileVisibilityDemo 类

```java
@Data
public class VolatileVisibilityDemo implements Runnable{
    private /*volatile*/ boolean isContinuePrintPrint = true;

    public void printStringMethodMethod(){
        try{
            while (Boolean.TRUE.equals(isContinuePrintPrint)) {
            }
            System.out.println("printStringMethodMethod stop");
        }catch (Exception e){
            // doNothing
        }
    }

    public void run() {
        printStringMethodMethod();
    }
}
```

创建测试类

```java
public class VolatileVisibilityDemoTest {
    public static void main(String[] args) {
        VolatileVisibilityDemo volatileVisibilityDemo = new VolatileVisibilityDemo();
        Thread thread = new Thread(volatileVisibilityDemo);

        thread.start();

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // doNothing
        }
        System.out.println("stop volatileVisibilityDemo method");
        volatileVisibilityDemo.setContinuePrintPrint(false);
    }
}
```

在程序运行一段时间后, 将循环条件 isContinuePrintPrint 置为 false, 终止循环。运行程序看下结果:

```text
start run printStringMethodMethod isContinuePrintPrint = true
stop volatileVisibilityDemo method
……

```

可以看到线程并没有结束, 一直在等待。 这是因为线程之间变量的不可见性。举个例子, 如图

![多线程内存模型](../photo/1.多线程内存模型.png)

每个线程都会各自开辟自己的工作空间并且会从主内从中拷贝一份共享变量到自己的工作内存中

假设此时这个系统刚好有两个线程同时运行：A、B, 这两个线程都会将从主内存中复制一份共享变量到自己的工作内存中, 共享变量的修改对于其他线程来说并不可见, 因此
线程没有被终止。

在《深入理解 Java 虚拟机》 一书中对于主内存与工作内存有这样的一段描述:

Java 内存模型规定了所有变量都存储在主内存中。每条线程具有自己的工作内存, 工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作都必须在
工作内存中进行, 而不能直接读写主存中的数据。同时不同线程之间也无法直接访问对方工作内存中的变量。

这也就导致了上述示例线程无法停止的原因。

当我们使用 volatile 修饰 isContinuePrintPrint 变量, 此时再次运行程序观察结果

```text
start run printStringMethodMethod isContinuePrintPrint = true
stop volatileVisibilityDemo method
printStringMethodMethod stop isContinuePrintPrint = false
```

可以看到线程结束了。使用 volatile关键字, 可以强制线程每次修改变量后要刷新到主存，线程每次都要  从公共内存中读取变量的值

关于 volatile 变量的可见性需要注意：既然 volatile 变量对所有线程都是可见的，那么是不是基于 volatile 变量的运算在并发下线程是安全的。这句话的
前半部分是并没有错, 但是基于前半部分得出的结论是有问题。因为在 Java 中的运算操作符并非都是原子操作。下面验证一下 volatile 是否能保证 java 中
操作符的原子性

## 2.原子性

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

```java
public class AtomicityDemo {
    public static volatile int race = 0;

    private static final int THREADS_COUNT = 20;

    public static void increase(){
        race++;
    }

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADS_COUNT];

        for(int i=0; i<THREADS_COUNT; i++){
            threads[i] = new Thread(new Runnable() {
                public void run() {
                    for (int i=0; i<1000; i++){
                        increase();
                    }
                }
            });
            threads[i].start();
        }

        // 等待所有累加线程都结束
        while(Thread.activeCount() > 1){
            Thread.yield();
        }

        System.out.println("race 的值为: " + race);
    }
}
```

运行结果：

```text

```


## 3.禁止代码重排序

即程序执行的顺序按照代码的先后顺序执行。