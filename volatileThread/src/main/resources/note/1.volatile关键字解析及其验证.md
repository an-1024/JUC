# Volatile 关键字

在多线程的领域中， volatile 关键字也是非常重要的。Volatile 在使用上具有以下特性

## 1.可见性：

B 线程能马上看到 A 线程更改的数据

先来看一个死循环的例子

创建 VolatileVisibilityDemo 类

```java
@Data
public class VolatileVisibilityDemo implements Runnable{
    private /*volatile*/ boolean isContinuePrintPrint = true;

    public void printStringMethodMethod(){
        try{
            while (Boolean.TRUE.equals(isContinuePrintPrint)) {
            }
            System.out.println("printStringMethodMethod stop");
        }catch (Exception e){
            // doNothing
        }
    }

    public void run() {
        printStringMethodMethod();
    }
}
```

创建测试类

```java
public class VolatileVisibilityDemoTest {
    public static void main(String[] args) {
        VolatileVisibilityDemo volatileVisibilityDemo = new VolatileVisibilityDemo();
        Thread thread = new Thread(volatileVisibilityDemo);

        thread.start();

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // doNothing
        }
        System.out.println("stop volatileVisibilityDemo method");
        volatileVisibilityDemo.setContinuePrintPrint(false);
    }
}
```

在程序运行一段时间后, 将循环条件 isContinuePrintPrint 置为 false, 终止循环。运行程序看下结果:

```text
start run printStringMethodMethod isContinuePrintPrint = true
stop volatileVisibilityDemo method
……

```

可以看到线程并没有结束, 一直在等待。 这是因为线程之间变量的不可见性。举个例子, 如图

![多线程内存模型](../photo/1.多线程内存模型.png)

每个线程都会各自开辟自己的工作空间并且会从主内从中拷贝一份共享变量到自己的工作内存中

假设此时这个系统刚好有两个线程同时运行：A、B, 这两个线程都会将从主内存中复制一份共享变量到自己的工作内存中, 共享变量的修改对于其他线程来说并不可见, 因此
线程没有被终止。

在《深入理解 Java 虚拟机》 一书中对于主内存与工作内存有这样的一段描述:

Java 内存模型规定了所有变量都存储在主内存中。每条线程具有自己的工作内存, 工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作都必须在
工作内存中进行, 而不能直接读写主存中的数据。同时不同线程之间也无法直接访问对方工作内存中的变量。

这也就导致了上述示例线程无法停止的原因。

当我们使用 volatile 修饰 isContinuePrintPrint 变量, 此时再次运行程序观察结果

```text
start run printStringMethodMethod isContinuePrintPrint = true
stop volatileVisibilityDemo method
printStringMethodMethod stop isContinuePrintPrint = false
```

可以看到线程结束了。使用 volatile关键字, 可以强制线程每次修改变量后要刷新到主存，线程每次都要从主内存中读取变量的值。

关于 volatile 变量的可见性需要注意：既然 volatile 变量对所有线程都是可见的，那么是不是基于 volatile 变量的运算在并发下线程是安全的。这句话的
前半部分是并没有错, 但是基于前半部分得出的结论是有问题。因为在 Java 中的运算操作符并非都是原子操作。下面验证一下 volatile 是否能保证 java 中
操作符的原子性

## 2.不保证原子性

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

```java
public class AtomicityDemo {
    public static volatile int race = 0;

    private static final int THREADS_COUNT = 20;

    public static void increase(){
        race++;
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[THREADS_COUNT];

        for(int i=0; i<THREADS_COUNT; i++){
            threads[i] = new Thread(new Runnable() {
                public void run() {
                    for (int i=0; i<1000; i++){
                        increase();
                    }
                }
            });
            threads[i].start();
        }

        // 等待所有累加线程都结束
        // idea 会自动创建一条名为 Monitor Ctrl-Break 的线程
        while (Thread.activeCount() > 2){
            Thread.yield();
        }


        System.out.println("race 的值为: " + race);
    }
}

```

运行结果：

```text
race 的值为: 19320
```

启动 20 个线程, 每个线程都对 race 变量进行 1000 次自增操作, 但是最终结果都是小于 20000。问题就在于 race++; 在启动参数中添加 
-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly, 运行程序可以看到, race++ 并不是一个原子操作

```text
……
# 静态变量 race 的地址为 0x68, 将 race 的值赋值给 edi 寄存器
0x0000000111ac3e62: mov    0x68(%rsi),%edi    ;*getstatic race
                                            ; - com.anzhi.atomicity.AtomicityDemo::increase@0 (line 9)
# 将 edi 寄存器中的值加1
0x0000000111ac3e65: inc    %edi
# 再将 edi 值赋值给 race
0x0000000111ac3e67: mov    %edi,0x68(%rsi)
#带lock前缀的加指令，把rsp所指向的地址中值加0，这个指令没啥用，主要使用lock前缀做内存屏障的
#防止lock之后的指令在lock之前执行，这里没使用mfence指令，主要是mfence在某些情况下比lock效率慢
0x0000000111ac3e6a: lock addl $0x0,(%rsp)     ;*putstatic race
……

```
经过 4 条指令后, race 才完成了自加操作。 多线程下, 在执行 `lock addl $0x0,(%rsp)` 之前, race 的值可能已经被改变了, 
最终导致 race 的值小于 20000。要保证原子性, 最终还是需要加锁。

这里解释一下 lock 的作用: 

1. 在 lock 锁定的时候，如果操作某个数据，那么其他 CPU 核是不能同时操作的，即锁定了
2. lock 锁定的指令，不能上下文随意排序执行，必须按照程序上下顺序执行
3. 在 lock 锁定操作完毕之后，如果某个数据被修改了，那么需要立即告诉其他 CPU 这个值被修改了，使它们的缓存数据立即失效，需要重新到内存获取

## 3.禁止指令重排序(有序性)

volatile 的有序是通过 JVM 提供的四种基本的内存屏障保证。

1. LoadLoad 作用于：Load1；LoadLoad：Load2，确保 Load1 一定是在 Load2 以及其后的指令之前完成，在指令执行的时候，Load1 绝对不会到 Load2 之后执行；

2. StoreStore 作用于：Store1；StoreStore：Store2，确保 Store1 一定是在 Store2 以及其后的指令之前完成（同时，Store1 的写入数据会立即被其他 CPU 
看到，也就是可见性），在指令执行的时候，Store1 绝对不会到 Store2 之后执行；

3. LoadStore 作用于：Load1；LoadStore：Store2，确保 Load1 一定是在 Store2 以及其后的指令之前完成，并且 Load1 绝对不会到 Store2 之后执行；

4. StoreLoad 作用于：Store1；StoreLoad：Load2，确保 Store1 一定在 Load2 以及其后的指令之前完成，并且 Store1 绝对不会到 Load2 之后执行；

从以上的四种内存屏障说明中我们可以看到，volatile 的「有序性」会得到保证，并且 Store 指令也会保证「可见性」。

参考 《Createchance 的博客: 一次深入骨髓的 volatile 研究》:

在 JVM 内部实现 volatile 访问的时候都需要如下格式:

![img.png](../photo/2.volatile内存屏障.png)

如上两个图描述 volatile 字段在读和写的时候需要的内存屏障操作，我们首先来看读操作，在读操作之前的 LoadLoad 屏障要求这个读操作之前的所有读
操作不能在这个读操作之后完成，必须按照上下顺序执行，读操作之后的 LoadStore 要求这个读操作不能在之后的写操作之后完成，必须在之前完成。同样的，
写操作前后的屏障也是定义了类似的有序性要求。对于上下文读写操作来说，无非就是如下几种组合：

![img.png](../photo/4.volatile内存屏障组合.png)




