# 垃圾收集算法
如图是目前 JVM 用到的垃圾收集算法：
![](../photo/9.垃圾收集算法.png)
图中介绍了几种算法的思想，下面介绍一下这几种算法的演进。
## 复制算法
复制算法的弊端比较明显，总有一块儿内存是空着的啥事不干，就等着将存活的对象放入，显然这中算法是不可取的。而且影响程序运行效率。
![标记复制算法](../photo/10.标记复制算法.png)
## 标记清除算法
为了解决上面内存浪费，效率低下的问题，标记清除算法先**标记对象**，然后**清除对象**，这种算法虽然没有内存浪费的情况出现，但是会带来以下两个
![标记清除算法](../photo/11.标记清除算法.png)

问题：
1. 如果标记对象很多，效率是一个问题；
2. 会产生内存碎片：比如这次回收了 1K 的数据，此时需要放入 2K 数据，因为没有连续的空间，且如果以后再没有 1K 的数据，那么这块空间就永远用不上了，
这就产生了内存碎片；也会造成内存浪费；
## 标记整理算法
这个算法解决了标记清除算法中内存碎片的问题，与标记清除算法前面两个阶段一样，都需要标记清除。在清除之前，需要移动对象到另一端(可以理解为整理对象)，然后以这个端
为边界，清除所有垃圾对象。但是这种算法同样存在效率问题，大对象的来回移动会造成效率低下。

![](../photo/12.标记整理算法.png)
## 分代收集算法
分代垃圾收集算法是根据分代区域的不同，使用不同的垃圾算法进行垃圾回收。
# 垃圾收集器
前面垃圾收集算法只是一个大体的思路，并没有提供具体的实现。垃圾收集器才是内存收集的具体实现。下面来介绍一下这些垃圾收集器。

## Serial
Serial 收集器年轻代的收集器，采用复制算法。它是一个"单线程"工作的收集器，但是需要注意它"单线程"的意义不仅仅只是说明它只会用一个处理器或
一条收集垃圾的线程，更重要的是 它在进行垃圾收集时，必须暂停其他所有的线程，也就是 STW(Stop The World)。由于这是由底层 JVM 完成，对于用
户来说并不可控。如果 GC 时间老长的话，对于用户来说是不可接受的。工作图如下：
![](../photo/13.Serial垃圾收集器.png)

照这样描述，Serial 垃圾器似乎该被淘汰了，事实上，它依然是 HotSpot 虚拟机运行在客户端模式下的默认新生代垃圾收集器。对于内存环境受限的环境，它是
所有收集器中额外内存消耗最少的，并且对于单核处理器或者处理器核心数较少的环境来说，Serial 收集由于没有线程交互，专心做垃圾回收可以获得最高的单线程
收集效率。

所以对于一些微服务的应用来说，分配给虚拟机管理的内存并不大，垃圾收集停顿的时间完全可以控制在十几、几十毫秒，只要不是频繁地 GC，这点
停顿完全可以接受。

## Serial Old 收集器
Serial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器，采用标记整理算法。

## Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))
Parallel Scavenge 是一款新生代的垃圾收集器，同样基于标记-复制算法实现。与 Serial 收集器不同的是 Parallel Scavenge 是多线程收集器。
默认的收集线程数跟cpu核数相同，当然也可以用参数(- XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。

相比于其他收集器关注点不同，Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。吞吐量计算公示：

$吞吐量={用户运行代码时间 \over 用户运行代码时间+运行垃圾收集时间}$

Parallel Scavenge 收集器提供了两个参数用于精准控制吞吐量：
1. -XX:GCTimeRatio : 直接设置吞吐量；
2. -XX:MaxGCPauseMills : 控制垃圾收集器最大停顿时间(但是需要注意，不是把参数设置的小一点，垃圾收集速度就变得更快，垃圾停顿时间缩短是以牺牲
吞吐量和新生代空间为代价换取的，新生代调得小一些，就意味着 GC 会变得很频繁，从而导致吞吐量下降)；
3. -XX:+UseAdaptiveSizePolicy: 当设置了这个参数，JVM 会自适应的调整各个区的比例，不需要人工调节了；

Parallel Old/Parallel Scavenge 收集器运行示意图:
![Parallel Old:Parallel Scavenge](../photo/14.Parallel Old:Parallel Scavenge.png)

## Parallel Old 收集器
Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU资源的场合，都可以优先考虑
Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集 器)。

## ParaNew 收集器
ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。 新生代采用复制算法，老年代采用标记-整理算法。

## CMS收集器(-XX:+UseConcMarkSweepGC(old))
CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体 验的应用上使用，它是HotSpot虚拟机
第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。
CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面 几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤:
1. **初始标记**: 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。
2. **并发标记**: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但 是不需要停顿用户线程， 可以与垃圾收
集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。
3. 重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会
比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三 色标记里的增量更新算法(见下面详解)做重新标记。
4. 并发清理: 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑 色不做任何处理(见下面三色标记算法详解)。
5. 并发重置:重置本次GC过程中的标记数据。

如下是 CMS 垃圾收集器运行示意图
![CMS收集器](../photo/15.CMS收集器.png)

从运行图可以看出来 CMS 是一款优秀的垃圾收集器。它具有并发收集、低停顿的优点。但是 CMS 并也并不完美。也有以下几个缺点：
1. 对CPU资源敏感(会和服务抢资源): 就是在并发标记、并发清除的时候，CMS 会和用户争夺 CPU 资源，会影响程序的运行；
2. 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)：浮动垃圾产生的原因是因为在并发阶段，用户线程
还在不断的运行，自然就会产生新的垃圾，这种垃圾是在标记之后产生的。这种垃圾是没有办法在这次清理的，只能在下一次垃圾收集时再清理掉。
3. 执行的不确定性：前面也提到过，CMS 会产生浮动垃圾，所以 CMS 不能等到老年代被填满了再进行 Full GC，需要预留一些空间。否则在 CMS 运行期
间预留的内存无法满足程序分配新对象的需要，就会出现"并发失败(Concurrent Mode Failure)"，这时候虚拟机不得不启动后备预案：冻结用户线程执行，
临时启动 Serial Old 收集器进行老年代的垃圾收集，但是这样 STW 时间就非常长了；
4. 会残留空间碎片：因为采用的是标记清除算法，会产生空间碎片，这会导致即使老年代有空间，但是无法存放对象。因此 CMS 提供了一个 -XX:+UseCMSCompactAtFullCollection
开关参数(默认是开启的，此参数从JDK9开始废弃)。但是这又会导致停顿时间变长，于是 CMS 又提供了另一个参数：-XX:CMSFullGCsBeforeCompaction， CMS
执行若干次之后，再整理空间(同样从 JDK9 开始废弃)。

### CMS 相关核心参数：
1. -XX:+UseConcMarkSweepGC:启用cms
2. -XX:ConcGCThreads:并发的GC线程数
3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)
4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 6. -XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整
6. -XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段
7. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW
8. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;

### JVM 模型调优
大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系 统等等。
这里以比较核心的订单系统为例。如图：
![](../photo/16.CMS调优-订单系统模型.png)
对于 8G 的内存，一般会分配 4G 的内存给 JVM。那么按照正常的配置，大致参数如下：
```text
‐Xms3072M ‐Xmx3072M ‐Xss1M ‐XX:MetaspaceSize=512M ‐XX:MaxMetaspaceSize=512M ‐XX:SurvivorRatio=8
```
那么对应的内存模型如下：
![CMS调优-订单模型内存](../photo/17.CMS调优-订单模型内存.png)

不以模型计算的话，直接按照上述分配：堆分配 3G，元空间分配 512M，Eden 区与 Survivor 区空间比例 8:1:1。这种参数配置在模拟的场景下会有问题的。
分析一下：

线程每秒产生 60M 对象，Eden 区有 800M 大小，在第 14 秒的时候，就要发生一次 Minor GC。此时前面 13s 的对象基本上已经被回收了，因为 Minor GC
要 STW，所以第 14s 的订单对象可能无法被回收，那么这 60M 对象就会被放入 Survivor 区。虽然 Survivor 有 100M 的空间，完全可以放入这 60M 对象，
但是不要忘记 JVM 针对 Survivor 的优化：对象动态年龄判断。60M 已占用了 Survivor 区空间的 60%，所以这个对象并不会被放入 Survivor，而是会
被直接放入老年代。按照这种情况推算，老年代有 2G 的空间，大概 400s 就会发生一次 Full GC，也就大概 7 分钟一次 Full GC，这么频繁地 GC，对于系统
来说显然是不允许的。

通过分析可以知道，根本原因是因为年轻代的 Survivor 太小，导致 Minor GC 的时候，由于动态年龄的判断导致对象直接放入老年代，从而频繁的 Full GC。
那么我们可以尝试将年轻代的空间放大，老年代空间调小。

```text
‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=8
```
将年轻代大小调整为 2G，那么 Eden 区为 1.6G, Survivor 区为 200M。那么 Eden 区放满大概需要 25s，第 26 秒的时候进行 Minor GC，然后将 60M
对象放入 Survivor 区。当下个第 26s 的时刻，才会有新的对象放入 Survivor 区，而到了这个时候，Survivor 区之前存放的对象，在 Minor GC 的时候
已经回收掉了。这样不仅减少了 Minor GC 的频率，Full GC 几乎不进行(理论上是这样)。

针对上面的模型，还可以进一步进行优化-对象的年龄。因为订单相关对象消亡很快，所以在年轻代中的年龄不会很大，而那些年龄很大一般就是 JVM 自己创建
的对象，或者是 Spring 框架自己的对象。针对这些系统对象，应该及早的让它们进入老年代，而不是占用着年轻代的空间。所以可以将 JVM 默认的age=12 可以
调整成 5，也就经历 5 次 Minor GC 的对象还不消亡，那么很可能就是系统对象，那么就让早早地进入老年代。关于年龄的参数只能在实际的过程中调整，并不是固定
的。

进一步分析之后，JVM 运行参数调整如下：
```text
‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=8 
‐XX:MaxTenuringThreshold=5 ‐XX:PretenureSizeThreshold=1M
```
指定了 JVM 中对象的年龄，以及对大对象大小的认定值。

### CMS 的调优
基于上面的模型，来分析一下 CMS 如何调优。

对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验 值)，系统对
停顿时间比较敏感，我们可以使用ParNew+CMS(-XX:+UseParNewGC -XX:+UseConcMarkSweepGC)。基于上面的分析，可以从一下几个方面入手：
1. 经历几次的对象认为是系统对象，而不会被 GC 回收；
2. 在秒杀的时候，系统压力激增，此时每秒数据可能激增到上百兆，一个订单可能用好几秒才能处理完，那么就有可能 26s、27s、28s 这些数据都会直接到
老年代，大概 100M左右。乐观一点，这种情况大概 5、6 分钟出现一次，那么一次 Full GC 触发的频率基本上就是半小时或者一小时左右一次。这种基本已经
扛过了抢购了；Full GC的触发条件还有我们之前说过的老年代空间分配担保机制，历次的minor gc挪动到老年代的对象大小 肯定是非常小的，所以几乎
不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc
3. 标记清除算法会产生内存碎片，需要在 JVM 的运行参数设定碎片整理的参数；

基于上述分析，只要年轻代分配合理，其余参数可以默认，至于整理碎片的频率可以是每次 Full GC 回收或者隔个两三次进行回收。
```text
‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=8
‐XX:MaxTenuringThreshold=5 ‐XX:PretenureSizeThreshold=1M ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC
‐XX:CMSInitiatingOccupancyFraction=92 ‐XX:+UseCMSCompactAtFullCollection ‐XX:CMSFullGCsBeforeCompaction=2
```
堆分分配大小没变，使用 ParNew 配合 CMS 垃圾收集器，指定老年代使用阈值，开启整理内存碎片以及每隔多少次开始内存碎片的整理。

### 补充(设置元空间大小的必要性)


### CMS 垃圾收集器底层算法
在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。
这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以 下三种颜色。

1. 黑色: 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描 过， 它是安全存活的， 如果有其他对象
引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接(不经过 灰色对象) 指向某个白色对象。
2. 灰色: 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
3. 白色: 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象，
即代表不可达。
![三色标记示意图](../photo/18.三色标记示意图.png)

对应的 demo 如下：
```java
/**
 * 三色标记模型
 */
public class ThreeColorModelDemo {
    public static void main(String[] args) {
        MarkA markA = new MarkA();
        // 开始做并发标记，标记根结点的引用
        
    }

    static class MarkA {
        MarkB markB = new MarkB();
        MarkD markD = null;
    }

    static class MarkB{
        MarkC markC = new MarkC();
        MarkD markD = new MarkD();

    }

    static class MarkC{

    }

    static class MarkD{

    }
}
```
在 GC 的那一刻，先从 gc roots 从 A 开始扫描，扫描到 B，此时 A 就可以被标记为黑色，因为 A 对象的引用被扫描过了。
还是接着上一步，扫描到 B 之后，再接着从 B 开始扫描，扫描到 C，但是 D 没有被扫描到，所以**此刻** B 对象被标记为灰色；接着从 C
开始扫描，此时 C 没有其他引用，所以，C 对象被标记为黑色；D 因为没有被扫描到，所以**此刻**被标记为白色。

以上就是三色标记的大致过程。

#### 漏标是怎么产生的
在并发标记的过程中，在完成 A 的扫描后，即 A 被标记为黑色；因为是并发收集，在 扫描 B 的时候，刚刚扫描完它的一个引用 C，还没来得及扫描 D，正
准备扫描 D 的时候。此时有用户线程将 B 指向 D 应用断开了，然后将 A 的引用指向了 D。当再次扫描的时候，因为 A 被标记为黑色，是不会在扫描 D 了，
而 B 中断开了 D 的引用，最终导致 D 没有被标记为黑色，在 GC 的时候被当作垃圾对象回收掉了。这就是漏标。

#### 漏标的解决办法
漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案: 

增量更新(Incremental Update) 和原始快照(Snapshot At The Beginning，SATB) 。 
1. 增量更新就是当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来， 等并发扫描结束之 后， 再将这些记录过的引用关系
中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。
2. 原始快照就是当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰
色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时
候重新扫描，这个对象也有可能是浮动垃圾) 以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过"写屏障"实现的。

要特别注意的是这里的"写屏障"与JVM内存模型中的"写屏障"两个是不同意思，两者没有任何关联。虚拟机中的"写屏障"指的是在赋值操作前后加入一些处理(异步处理提高效率)，
类似与 Spring 中的 AOP。后者是目的是保证线程并发安全的。

现代追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同:比如白色/黑色 集合一般都不会出现(但是有其他体现颜色的地方)、
灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可 以是广度/深度遍历等等。

![](../photo/19.CardTable.png)

对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下:
1. CMS:写屏障 + 增量更新 G1，Shenandoah:写屏障 + SATB ZGC:读屏障
2. 工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并 发执行等。功能之外，
还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。

## 记忆集与卡表
在新生代做  GCRoots 可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。 为此，在新生代可以引入记录集
(Remember Set)的数据结构(记录从非收集区到收集区的指针集合)，避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有
跨代引用的问题，所有涉及部分区域收集 (Partial GC) 行为的垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题。垃圾收集场
景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。

hotspot使用一种叫做“卡表”(cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。
卡表是使用一个字节数组实现:CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡 页”。
hotSpot使用的卡页是2^9大小，即512字节

一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变 脏，否则为0.
GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。

### 卡表的维护 
卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。 
Hotspot使用写屏障维护卡表状态。










