# 垃圾收集算法
如图是目前 JVM 用到的垃圾收集算法：
![](../photo/9.垃圾收集算法.png)
图中介绍了几种算法的思想，下面介绍一下这几种算法的演进。
## 复制算法
复制算法的弊端比较明显，总有一块儿内存是空着的啥事不干，就等着将存活的对象放入，显然这中算法是不可取的。而且影响程序运行效率。
![标记复制算法](../photo/10.标记复制算法.png)
## 标记清除算法
为了解决上面内存浪费，效率低下的问题，标记清除算法先**标记对象**，然后**清除对象**，这种算法虽然没有内存浪费的情况出现，但是会带来以下两个
![标记清除算法](../photo/11.标记清除算法.png)

问题：
1. 如果标记对象很多，效率是一个问题；
2. 会产生内存碎片：比如这次回收了 1K 的数据，此时需要放入 2K 数据，因为没有连续的空间，且如果以后再没有 1K 的数据，那么这块空间就永远用不上了，
这就产生了内存碎片；也会造成内存浪费；
## 标记整理算法
这个算法解决了标记清除算法中内存碎片的问题，与标记清除算法前面两个阶段一样，都需要标记清除。在清除之前，需要移动对象到另一端(可以理解为整理对象)，然后以这个端
为边界，清除所有垃圾对象。但是这种算法同样存在效率问题，大对象的来回移动会造成效率低下。

![](../photo/12.标记整理算法.png)
## 分代收集算法
分代垃圾收集算法是根据分代区域的不同，使用不同的垃圾算法进行垃圾回收。
# 垃圾收集器
前面垃圾收集算法只是一个大体的思路，并没有提供具体的实现。垃圾收集器才是内存收集的具体实现。下面来介绍一下这些垃圾收集器。

## Serial
Serial 收集器年轻代的收集器，采用复制算法。它是一个"单线程"工作的收集器，但是需要注意它"单线程"的意义不仅仅只是说明它只会用一个处理器或
一条收集垃圾的线程，更重要的是 它在进行垃圾收集时，必须暂停其他所有的线程，也就是 STW(Stop The World)。由于这是由底层 JVM 完成，对于用
户来说并不可控。如果 GC 时间老长的话，对于用户来说是不可接受的。工作图如下：
![](../photo/13.Serial垃圾收集器.png)

照这样描述，Serial 垃圾器似乎该被淘汰了，事实上，它依然是 HotSpot 虚拟机运行在客户端模式下的默认新生代垃圾收集器。对于内存环境受限的环境，它是
所有收集器中额外内存消耗最少的，并且对于单核处理器或者处理器核心数较少的环境来说，Serial 收集由于没有线程交互，专心做垃圾回收可以获得最高的单线程
收集效率。

所以对于一些微服务的应用来说，分配给虚拟机管理的内存并不大，垃圾收集停顿的时间完全可以控制在十几、几十毫秒，只要不是频繁地 GC，这点
停顿完全可以接受。

## Serial Old 收集器
Serial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器，采用标记整理算法。

## Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))
Parallel Scavenge 是一款新生代的垃圾收集器，同样基于标记-复制算法实现。与 Serial 收集器不同的是 Parallel Scavenge 是多线程收集器。
默认的收集线程数跟cpu核数相同，当然也可以用参数(- XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。

相比于其他收集器关注点不同，Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。吞吐量计算公示：

$吞吐量={用户运行代码时间 \over 用户运行代码时间+运行垃圾收集时间}$

Parallel Scavenge 收集器提供了两个参数用于精准控制吞吐量：
1. -XX:GCTimeRatio : 直接设置吞吐量；
2. -XX:MaxGCPauseMills : 控制垃圾收集器最大停顿时间(但是需要注意，不是把参数设置的小一点，垃圾收集速度就变得更快，垃圾停顿时间缩短是以牺牲
吞吐量和新生代空间为代价换取的，新生代调得小一些，就意味着 GC 会变得很频繁，从而导致吞吐量下降)；
3. -XX:+UseAdaptiveSizePolicy: 当设置了这个参数，JVM 会自适应的调整各个区的比例，不需要人工调节了；

Parallel Old/Parallel Scavenge 收集器运行示意图:
![Parallel Old:Parallel Scavenge](../photo/14.Parallel Old:Parallel Scavenge.png)

## Parallel Old 收集器
Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU资源的场合，都可以优先考虑
Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集 器)。

## ParaNew 收集器
ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。 新生代采用复制算法，老年代采用标记-整理算法。

## CMS收集器(-XX:+UseConcMarkSweepGC(old))
CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体 验的应用上使用，它是HotSpot虚拟机
第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。
CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面 几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤:
1. **初始标记**: 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。
2. **并发标记**: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但 是不需要停顿用户线程， 可以与垃圾收
集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。
3. 重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会
比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三 色标记里的增量更新算法(见下面详解)做重新标记。
4. 并发清理: 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑 色不做任何处理(见下面三色标记算法详解)。
5. 并发重置:重置本次GC过程中的标记数据。

如下是 CMS 垃圾收集器运行示意图
![CMS收集器](../photo/15.CMS收集器.png)

从运行图可以看出来 CMS 是一款优秀的垃圾收集器。它具有并发收集、低停顿的优点。但是 CMS 并也并不完美。也有以下几个缺点：
1. 对CPU资源敏感(会和服务抢资源): 就是在并发标记、并发清除的时候，CMS 会和用户争夺 CPU 资源，会影响程序的运行；
2. 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)：浮动垃圾产生的原因是因为在并发阶段，用户线程
还在不断的运行，自然就会产生新的垃圾，这种垃圾是在标记之后产生的。这种垃圾是没有办法在这次清理的，只能在下一次垃圾收集时再清理掉。
3. 执行的不确定性：前面也提到过，CMS 会产生浮动垃圾，所以 CMS 不能等到老年代被填满了再进行 Full GC，需要预留一些空间。否则在 CMS 运行期
间预留的内存无法满足程序分配新对象的需要，就会出现"并发失败(Concurrent Mode Failure)"，这时候虚拟机不得不启动后备预案：冻结用户线程执行，
临时启动 Serial Old 收集器进行老年代的垃圾收集，但是这样 STW 时间就非常长了；
4. 会残留空间碎片：因为采用的是标记清除算法，会产生空间碎片，这会导致即使老年代有空间，但是无法存放对象。因此 CMS 提供了一个 -XX:+UseCMSCompactAtFullCollection
开关参数(默认是开启的，此参数从JDK9开始废弃)。但是这又会导致停顿时间变长，于是 CMS 又提供了另一个参数：-XX:CMSFullGCsBeforeCompaction， CMS
执行若干次之后，再整理空间(同样从 JDK9 开始废弃)。

### CMS 相关核心参数：
1. -XX:+UseConcMarkSweepGC:启用cms
2. -XX:ConcGCThreads:并发的GC线程数
3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)
4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 6. -XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整
6. -XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段
7. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW
8. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;

### CMS 模型调优
大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系 统等等。
这里以比较核心的订单系统为例。






