# JVM 内存结构
JVM 在运行的时候会将自己管理的区域划分为若干个不同的数据区域，如图所示：
![JVM内存结构](../photo/4.JVM内存结构.png)
1. 堆：程序运行过程中创建的的对象以及数组都要在堆上分配，这块区域是线程共享区域；
2. 栈：也可以称之为线程栈，存放线程的相关数据。因为程序启动就会有一个主线程开始执行，期间产生的数据就存放到栈内存中。比如：
   存储局部变量表、操作栈、动态链接、方法出口，对象指针；这块区域是线程私有的。
3. 本地方法栈：和栈一样，只不过这里是 C/C++ 代码运行的区域；这块区域是线程私有的；
4. 程序计数器：当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。这块区域是线程私有的；
5. 方法区：存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等；

# 栈
前面也说过在主程序执行的时候，JVM 会为这个线程分配栈，存放线程中的局部变量，对象等信息。
下面以一个简单的例子说明一下栈的布局：
```java
public class TestExample {
    public static final int initData = 666;

    public int compute(){ // 一个方法对应一块栈帧区域
        int a = 1;  // 局部变量
        int b = 2;

        int c = (a+b)*10;

        return c;
    }

    public static void main(String[] args) {  // 主线程
        TestExample testExample = new TestExample();
        int count = testExample.compute();
        System.out.println("test=" + count);
    }
}
```
使用 javap 命令对 TestExample.class 文件进行反汇编，输出到 TestExample.txt 文档中。
也可以用 javap -c -l -p -v 这个命令进行反汇编，会把操作栈的深度、以及占用槽的大小都表示出来。
```text
Compiled from "TestExample.java"
public class com.anzhi.jvmmemorystructure.TestExample {
  public static final int initData;

  public com.anzhi.jvmmemorystructure.TestExample();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public int compute();
    Code:
       0: iconst_1
       1: istore_1
       2: iconst_2
       3: istore_2
       4: iload_1
       5: iload_2
       6: iadd
       7: bipush        10
       9: imul
      10: istore_3
      11: iload_3
      12: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class com/anzhi/jvmmemorystructure/TestExample
       3: dup
       4: invokespecial #3                  // Method "<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #4                  // Method compute:()I
      12: istore_2
      13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
      16: new           #6                  // class java/lang/StringBuilder
      19: dup
      20: invokespecial #7                  // Method java/lang/StringBuilder."<init>":()V
      23: ldc           #8                  // String test=
      25: invokevirtual #9                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      28: iload_2
      29: invokevirtual #10                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      32: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      35: invokevirtual #12                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      38: return
}
```
具体过程参考 JVM 内存结构的图
![JVM内存结构](../photo/4.JVM内存结构.png)
根据图上的分析我们可以看到，程序开始运行，JVM 会分配一块儿"栈"区存放主线程的相关数据。上述代代码中：
1. 先将常量 1 放入操作数栈中，然后给局部变量的 a 赋值; 变量 b 的赋值过程也是如此；
2. 赋值完成之后，从局部变量中取出对应的值进行相加，然后压入栈中；
3. 再向操作栈中放入带符号的整型 10，进行相乘，放入栈中；
4. 将操作数栈中的数据取出，赋值给局部变量，然后再从局部变量取出返回

小结：
1. 操作数栈：从上面我们可以看出操作数栈主要用于保存计算的中间结果，同时作为临时变量的存储空间； 
2. 局部变量：局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽
(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。
虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量
(如long或double型)，则会连续使用两个连续的Slot来存储。
3. 动态链接：在 Java 的 class 文件中，一个方法需要调用另一个方法，需要将这些方法的符号应用转换为其内存地址中的直接引用。而符号引用存在
于方法区中的运行时常量池。Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调
用过程中的动态连接(Dynamic Linking)。这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部
分将在每次运行期间转化为直接引用，这类转化称为动态连接。
4. 方法返回：一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处
理器表确定的，栈帧中一般不会保存此部分信息。

# 堆-JVM 创建对象过程
对象创建的主要流程如图所示：

