# JVM 内存结构
JVM 在运行的时候会将自己管理的区域划分为若干个不同的数据区域，如图所示：
![JVM内存结构](../photo/4.JVM内存结构.png)
1. 堆：程序运行过程中创建的的对象以及数组都要在堆上分配，这块区域是线程共享区域；
2. 栈：也可以称之为线程栈，存放线程的相关数据。因为程序启动就会有一个主线程开始执行，期间产生的数据就存放到栈内存中。比如：
   存储局部变量表、操作栈、动态链接、方法出口，对象指针；这块区域是线程私有的。
3. 本地方法栈：和栈一样，只不过这里是 C/C++ 代码运行的区域；这块区域是线程私有的；
4. 程序计数器：当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。这块区域是线程私有的；
5. 方法区：存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等；

# 栈
前面也说过在主程序执行的时候，JVM 会为这个线程分配栈，存放线程中的局部变量，对象等信息。
下面以一个简单的例子说明一下栈的布局：
```java
public class TestExample {
    public static final int initData = 666;

    public int compute(){ // 一个方法对应一块栈帧区域
        int a = 1;  // 局部变量
        int b = 2;

        int c = (a+b)*10;

        return c;
    }

    public static void main(String[] args) {  // 主线程
        TestExample testExample = new TestExample();
        int count = testExample.compute();
        System.out.println("test=" + count);
    }
}
```
使用 javap 命令对 TestExample.class 文件进行反汇编，输出到 TestExample.txt 文档中。
也可以用 javap -c -l -p -v 这个命令进行反汇编，会把操作栈的深度、以及占用槽的大小都表示出来。
```text
Compiled from "TestExample.java"
public class com.anzhi.jvmmemorystructure.TestExample {
  public static final int initData;

  public com.anzhi.jvmmemorystructure.TestExample();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public int compute();
    Code:
       0: iconst_1
       1: istore_1
       2: iconst_2
       3: istore_2
       4: iload_1
       5: iload_2
       6: iadd
       7: bipush        10
       9: imul
      10: istore_3
      11: iload_3
      12: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class com/anzhi/jvmmemorystructure/TestExample
       3: dup
       4: invokespecial #3                  // Method "<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #4                  // Method compute:()I
      12: istore_2
      13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
      16: new           #6                  // class java/lang/StringBuilder
      19: dup
      20: invokespecial #7                  // Method java/lang/StringBuilder."<init>":()V
      23: ldc           #8                  // String test=
      25: invokevirtual #9                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      28: iload_2
      29: invokevirtual #10                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      32: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      35: invokevirtual #12                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      38: return
}
```
具体过程参考 JVM 内存结构的图
![JVM内存结构](../photo/4.JVM内存结构.png)
根据图上的分析我们可以看到，程序开始运行，JVM 会分配一块儿"栈"区存放主线程的相关数据。上述代代码中：
1. 先将常量 1 放入操作数栈中，然后给局部变量的 a 赋值，

