# 前置程序
首先我们在电脑上启动一个 web 程序，然后通过命令查看对应的进程。这里我自己启动了一个名叫 FirstSpringBootPrjApplication 的 web 程序
然后在终端输入 jps 查看当前运行进程(打了一个 jar 包，放在了 CentOS 上)：
```shell
jps

输出结果：
6000 first-spring-boot-prj-1.0.0-SNAPSHOT.jar
6802 Jps
```
前面是进程号，后面是进程名称。需要查看 FirstSpringBootPrjApplication 的内存信息，以及实例个数。

```shell
jmap -histo 6000

 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:          6284        8725192  [I (java.base@11.0.16.1)
   2:         71312        7797048  [B (java.base@11.0.16.1)
   3:         50572        1213728  java.lang.String (java.base@11.0.16.1)
   4:         11766        1035408  java.lang.reflect.Method (java.base@11.0.16.1)
   5:          7073         838472  java.lang.Class (java.base@11.0.16.1)
   6:         10649         596344  java.util.concurrent.ConcurrentHashMap$KeyIterator (java.base@11.0.16.1)
   7:         18284         585088  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.16.1)
   8:         12028         583832  [Ljava.lang.Object; (java.base@11.0.16.1)
   9:         22894         504984  [Ljava.lang.Class; (java.base@11.0.16.1)
  10:         13959         446688  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node (java.base@11.0.16.1)
  11:          4263         372288  [Ljava.util.HashMap$Node; (java.base@11.0.16.1)
  12:         11181         357792  java.util.HashMap$Node (java.base@11.0.16.1)
  13:          8597         343880  java.util.LinkedHashMap$Entry (java.base@11.0.16.1)
  14:           987         219104  [C (java.base@11.0.16.1)
  15:           285         219024  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.16.1)
  16:          3812         213472  java.util.LinkedHashMap (java.base@11.0.16.1)
  17:          9017         144272  java.lang.Object (java.base@11.0.16.1)
……

num:序号
instances:实例数量
bytes:占用空间大小
class name:类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]
```
# 堆信息打印
输入命令
```shell
jmap -heap 6000
```

可以看到新生代的大小，以及和老年代的比例等这些信息。
```text
using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 994050048 (948.0MB)
   NewSize                  = 20971520 (20.0MB)
   MaxNewSize               = 331350016 (316.0MB)
   OldSize                  = 41943040 (40.0MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 190840832 (182.0MB)
   used     = 10285584 (9.809097290039062MB)
   free     = 180555248 (172.19090270996094MB)
   5.389613895625859% used
From Space:
   capacity = 7864320 (7.5MB)
   used     = 0 (0.0MB)
   free     = 7864320 (7.5MB)
   0.0% used
To Space:
   capacity = 7864320 (7.5MB)
   used     = 0 (0.0MB)
   free     = 7864320 (7.5MB)
   0.0% used
PS Old Generation
   capacity = 36175872 (34.5MB)
   used     = 11148056 (10.631614685058594MB)
   free     = 25027816 (23.868385314941406MB)
   30.8162744494452% used

12207 interned Strings occupying 1048976 bytes.
```
# 堆内存 dump-jmap 命令
```shell
jmap -dump:format=b,file=test.hprof 6000 
```
执行完成后会输出一个 test.hprof 的二进制文件。
```text
Dumping heap to /home/azh/Dev_Azh/test.hprof ...
Heap dump file created
```

## OOM dump文件测试
可以在运行参数中设置 OOM 自动导出 dump 文件(文件很大的时候，不要设置，不然服务器容易炸)
测试demo
```java
/**
 * 测试 OOM
 * 设置 JVM 运行参数：-Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/java/com/anzhi/jvmoptimization/oom.dump
 */
public class OomDemo {
    public static List<Object> objectList = new ArrayList<>();

    public static void main(String[] args) {
        int i=0;
        int j=0;
        while(true){
            objectList.add(new Object());
        }
    }
}
```
程序出现 OutOfMemoryError 异常，利用 jvisualvm 导入 dump 文件，可以看到是因为创建了大量的 Object 对象导致内存溢出。如图：
![](../photo/26.OOM%20deump文件分析.png)

# Jstack 命令
用jstack加进程id查找死锁，见如下示例
```java
public class DeadLock {
    private static CountDownLatch lock1 = new CountDownLatch(1);
    private static CountDownLatch lock2 = new CountDownLatch(1);

    public static void main(String[] args) {
        new Thread(()->{
            try {
                System.out.println("T1 线程开始执行");
                lock1.await();
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                // doNothing
            }
            lock2.countDown();
            System.out.println("T1 线程结束");
        }, "T1").start();

        new Thread(()->{
            try {
                System.out.println("T2 线程开始执行");
                lock1.await();
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                // doNothing
            }
            lock2.countDown();
            System.out.println("T2 线程结束");
        }, "T2").start();
    }
}
```
输出结果：
```text
T1 线程开始执行
T2 线程开始执行
```
程序最终阻塞到这里。使用 jstack 命令查看线程信息：
```shell
jsp 查看当前运行线程
输出结果
78642 Jps
78599 Main
71384 
78619 DeadLock
78618 Launcher

DeadLock 线程 id 为： 78619

执行 jstack -l 78619 查看当前线程信息

"T2" #20 prio=5 os_prio=31 tid=0x00007fb3d10d3800 nid=0x9703 waiting on condition [0x00007000097a1000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x000000066ac1eae0> (a java.util.concurrent.CountDownLatch$Sync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at com.anzhi.jvmoptimization.DeadLock.lambda$main$1(DeadLock.java:25)
	at com.anzhi.jvmoptimization.DeadLock$$Lambda$2/1989780873.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- None

"T1" #19 prio=5 os_prio=31 tid=0x00007fb3d70f8000 nid=0x6003 waiting on condition [0x000070000969e000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x000000066ac1eab0> (a java.util.concurrent.CountDownLatch$Sync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at com.anzhi.jvmoptimization.DeadLock.lambda$main$0(DeadLock.java:13)
	at com.anzhi.jvmoptimization.DeadLock$$Lambda$1/2093631819.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- None
	
可以看到是阻塞在 CountDownLatch 这个对象
```
也可以通过 jvisualvm 查看当前线程的运行信息。

远程连接服务器这一块儿就不操作了，一般来说，生产的东西我们基本是无法连接的。

## jstack找出占用cpu最高的线程堆栈信息
使用 top 命令查询当前占用 CPU 最高的线程
```shell
top -c 查看当前占用 CPU 最高的进程程是那个

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                        
13354 azh       20   0 3420896  46576  12360 S  79.3  1.2   0:08.51 java CpuHighDemo       

top -H -p 13354  查看当前进程中占用 CPU 最高的线程是那个
  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                         
13355 azh       20   0 3420896  46576  12360 R 77.7  1.2   0:56.96 java     

jstack 13354 ｜ grep -A 30 0x342b 注意这里的 00x342b 是线程 13354 的十六进制表示

"main" #1 prio=5 os_prio=0 tid=0x00007fc77004b800 nid=0x342b runnable [0x00007fc777067000]
   java.lang.Thread.State: RUNNABLE
	at java.io.FileOutputStream.writeBytes(Native Method)
	at java.io.FileOutputStream.write(FileOutputStream.java:326)
	at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
	at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
	- locked <0x00000000c4c1dbd8> (a java.io.BufferedOutputStream)
	at java.io.PrintStream.write(PrintStream.java:482)
	- locked <0x00000000c4c07150> (a java.io.PrintStream)
	at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
	at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
	at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)
	- locked <0x00000000c4c070e0> (a java.io.OutputStreamWriter)
	at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)
	at java.io.PrintStream.write(PrintStream.java:527)
	- eliminated <0x00000000c4c07150> (a java.io.PrintStream)
	at java.io.PrintStream.print(PrintStream.java:669)
	at java.io.PrintStream.println(PrintStream.java:806)
	- locked <0x00000000c4c07150> (a java.io.PrintStream)
	at CpuHighDemo.compute(CpuHighDemo.java:7)
	at CpuHighDemo.main(CpuHighDemo.java:13)
```
可以看到最先面是因为调用了 compute 方法，导致CPU 飙升，大概率是这里存在问题。

# Jinfo 命令

## JVM 参数查看
查看正在运行的Java应用程序的扩展参数，查看jvm的参数。
```shell
jinfo -flags 13713 查看当前线程 JVM 启动参数

Attaching to process ID 13713, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.362-b08
Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=62914560 -XX:MaxHeapSize=994050048 
-XX:MaxNewSize=331350016 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=20971520 -XX:OldSize=41943040 
-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 
```
可以看到使用了什么垃圾收集器 CMS + Parallel，老年代、年轻代大小等信息。

## 系统参数查看
```shell
jinfo -flags 13713

Attaching to process ID 13713, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.362-b08
Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=62914560 -XX:MaxHeapSize=994050048 -XX:MaxNewSize=331350016 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=20971520 -XX:OldSize=41943040 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 
Command line:  
[azh@CentOS_Dev]~% jinfo -sysprops 13713
Attaching to process ID 13713, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.362-b08
java.runtime.name = OpenJDK Runtime Environment
```
# Jstat

jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下: 

jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] 

注意:使用的jdk版本是jdk8

## GC 次数
```shell
jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况

 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
7168.0 7168.0  0.0    0.0   189440.0 14316.1   35328.0    11401.6   35456.0 33447.0 4480.0 4028.7     10    0.063   2      0.067    0.129
```

说明一下上面参数的意义
```text
S0C:第一个幸存区的大小，单位KB 
S1C:第二个幸存区的大小 
S0U:第一个幸存区的使用大小
S1U:第二个幸存区的使用大小 
EC:伊甸园区的大小 
EU:伊甸园区的使用大小 
OC:老年代大小
OU:老年代使用大小 
MC:方法区大小(元空间) 
MU:方法区使用大小 
CCSC:压缩类空间大小 
CCSU:压缩类空间使用大小 
YGC:年轻代垃圾回收次数 
YGCT:年轻代垃圾回收消耗时间，单位s 
FGC:老年代垃圾回收次数 
FGCT:老年代垃圾回收消耗时间，单位s 
GCT:垃圾回收消耗总时间，单位s
```
## 堆内存统计
```shell
jstat -gccapacity 13713

NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC 
 20480.0 323584.0 203776.0 7168.0 7168.0 189440.0    40960.0   647168.0    35328.0    35328.0      0.0 1081344.0  35456.0      0.0 1048576.0   4480.0     10     2
```
说明一下参数意义
```text
NGCMN:新生代最小容量 
NGCMX:新生代最大容量 
NGC:当前新生代容量 
S0C:第一个幸存区大小 
S1C:第二个幸存区的大小 
EC:伊甸园区的大小 
OGCMN:老年代最小容量 
OGCMX:老年代最大容量 
OGC:当前老年代大小 
OC:当前老年代大小 
MCMN:最小元数据容量 
MCMX:最大元数据容量 
MC:当前元数据空间大小 
CCSMN:最小压缩类空间大小 
CCSMX:最大压缩类空间大小 
CCSC:当前压缩类空间大小 
YGC:年轻代gc次数 
FGC:老年代GC次数
```

## 新生代垃圾回收统计
```text
jstat -gcnew 13713  

 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
7168.0 7168.0    0.0    0.0  1  15 7168.0 189440.0  14316.1     10    0.063
```
说明一下参数意义
```text

S0C:第一个幸存区的大小 
S1C:第二个幸存区的大小 
S0U:第一个幸存区的使用大小 
S1U:第二个幸存区的使用大小 
TT:对象在新生代存活的次数 
MTT:对象在新生代存活的最大次数 
DSS:期望的幸存区大小 
EC:伊甸园区的大小 
EU:伊甸园区的使用大小 
YGC:年轻代垃圾回收次数 
YGCT:年轻代垃圾回收消耗时间
```








