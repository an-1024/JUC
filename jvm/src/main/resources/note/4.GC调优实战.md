# 前置程序
首先我们在电脑上启动一个 web 程序，然后通过命令查看对应的进程。这里我自己启动了一个名叫 FirstSpringBootPrjApplication 的 web 程序
然后在终端输入 jps 查看当前运行进程(打了一个 jar 包，放在了 CentOS 上)：
```shell
jps

输出结果：
6000 first-spring-boot-prj-1.0.0-SNAPSHOT.jar
6802 Jps
```
前面是进程号，后面是进程名称。需要查看 FirstSpringBootPrjApplication 的内存信息，以及实例个数。

```shell
jmap -histo 6000
 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:          6284        8725192  [I (java.base@11.0.16.1)
   2:         71312        7797048  [B (java.base@11.0.16.1)
   3:         50572        1213728  java.lang.String (java.base@11.0.16.1)
   4:         11766        1035408  java.lang.reflect.Method (java.base@11.0.16.1)
   5:          7073         838472  java.lang.Class (java.base@11.0.16.1)
   6:         10649         596344  java.util.concurrent.ConcurrentHashMap$KeyIterator (java.base@11.0.16.1)
   7:         18284         585088  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.16.1)
   8:         12028         583832  [Ljava.lang.Object; (java.base@11.0.16.1)
   9:         22894         504984  [Ljava.lang.Class; (java.base@11.0.16.1)
  10:         13959         446688  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node (java.base@11.0.16.1)
  11:          4263         372288  [Ljava.util.HashMap$Node; (java.base@11.0.16.1)
  12:         11181         357792  java.util.HashMap$Node (java.base@11.0.16.1)
  13:          8597         343880  java.util.LinkedHashMap$Entry (java.base@11.0.16.1)
  14:           987         219104  [C (java.base@11.0.16.1)
  15:           285         219024  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.16.1)
  16:          3812         213472  java.util.LinkedHashMap (java.base@11.0.16.1)
  17:          9017         144272  java.lang.Object (java.base@11.0.16.1)
……

num:序号
instances:实例数量
bytes:占用空间大小
class name:类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]
```
# 堆信息打印
输入命令
```shell
jmap -heap 6000
```

可以看到新生代的大小，以及和老年代的比例等这些信息。
```text
using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 994050048 (948.0MB)
   NewSize                  = 20971520 (20.0MB)
   MaxNewSize               = 331350016 (316.0MB)
   OldSize                  = 41943040 (40.0MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 190840832 (182.0MB)
   used     = 10285584 (9.809097290039062MB)
   free     = 180555248 (172.19090270996094MB)
   5.389613895625859% used
From Space:
   capacity = 7864320 (7.5MB)
   used     = 0 (0.0MB)
   free     = 7864320 (7.5MB)
   0.0% used
To Space:
   capacity = 7864320 (7.5MB)
   used     = 0 (0.0MB)
   free     = 7864320 (7.5MB)
   0.0% used
PS Old Generation
   capacity = 36175872 (34.5MB)
   used     = 11148056 (10.631614685058594MB)
   free     = 25027816 (23.868385314941406MB)
   30.8162744494452% used

12207 interned Strings occupying 1048976 bytes.
```
# 堆内存 dump
```shell
jmap -dump:format=b,file=test.hprof 6000 
```
执行完成后会输出一个 test.hprof 的二进制文件。
```text
Dumping heap to /home/azh/Dev_Azh/test.hprof ...
Heap dump file created
```

## OOM dump文件测试
可以在运行参数中设置 OOM 自动导出 dump 文件(文件很大的时候，不要设置，不然服务器容易炸)
```shell
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./ (路径)
```






