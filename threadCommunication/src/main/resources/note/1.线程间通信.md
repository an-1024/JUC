 # wait/notify 机制

线程与线程之间不是独立的个体，彼此是可以互相通信协作的。先来介绍一下 wait/notify 机制。

## wait/notify 机制的原理

拥有相同锁的线程才可以实现 wait/notify 机制

### wait() 方法的基本使用

使用条件: 在使用 wait() 方法之前, 线程必须获得该对象的对象级别锁。这也就意味着只能在同步方法中或者同步代码块中使用此方法。notify 同样如此。

作用：wait() 方法的作用是使当前线程暂停运行, 并释放对象锁。

测试demo

```java
public class WaitThreadDemo_1 {
    public static void main(String[] args) {
        String newString = new String("");

        try {
            newString.wait();
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}
```

运行这段代码，结果抛出异常

```text
Exception in thread "main" java.lang.IllegalMonitorStateException
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:502)
	at waitandnotifythread.WaitThreadDemo_1.main(WaitThreadDemo_1.java:8)
```

这是因为在 Object 类中，wait 底层实现是一个 native 方法

```java
public class Object {
    /**
    * IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
    * @param timeout
    * @throws InterruptedException
    */
    public final native void wait(long timeout) throws InterruptedException;
}
```

异常注释翻译一下就是抛出 IllegalMonitorStateException 是因为 wait 在 JVM 通过 monitor 对象完成，main 方法执行的时候并没有获取到 String 对象的
monitor。

修改代码如下: 

```java
public class WaitThreadDemo_2 {
    public static void main(String[] args) {
        String lock = new String("");
        System.out.println("未获取 String 对象的 monitor 对象");
        synchronized(lock){
        try {
            System.out.println("获取到 String monitor 对象, 执行 wait 方法");
            lock.wait();
            System.out.println("执行 wait 方法后，是否能打印此行日志");
            } catch(InterruptedException e){
                // doNothing
            }
        }
    }
}
```

代码输出结果:

```text
未获取 String 对象的 monitor 对象
获取到 String monitor 对象, 执行 wait 方法

```

程序一直阻塞，并没有继续向下执行。如果要使处于 wait 状态的线程继续运行，就需要使用 notify 方法。demo 如下:

```java
public class WaitNotifyDemo {

    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    System.out.println("T1 start wait time = " + System.currentTimeMillis());
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        // doNothing
                    }
                    System.out.println("T1 end wait time = " + System.currentTimeMillis());
                }
            }
        }, "T1");

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    lock.notify();
                    System.out.println("T2 weak up T1 time = " + System.currentTimeMillis());
                }
            }
        }, "T2");

        t1.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }

        t2.start();
    }
}
```

创建两个线程, 对同一个对象上锁，t1 调用 wait 方法阻塞并释放锁，t2 调用 notify 通知线程 t1 并重新获取锁。这里需要注意的是 t1 获取锁是在 t2 线程执行完
成之后才可以获取 lock 对象锁。看下运行结果:

```text
T1 start wait time = 1656513516636
T2 weak up T1 time = 1656513519637
T1 end wait time = 1656513519637
```








