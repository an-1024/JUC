 # wait/notify 机制

线程与线程之间不是独立的个体，彼此是可以互相通信协作的。先来介绍一下 wait/notify 机制。

## wait/notify 机制的原理

拥有相同锁的线程才可以实现 wait/notify 机制

### wait() 方法的基本使用

使用条件: 在使用 wait() 方法之前, 线程必须获得该对象的对象级别锁。这也就意味着只能在同步方法中或者同步代码块中使用此方法。notify 同样如此。

作用：wait() 方法的作用是使当前线程暂停运行, 并释放对象锁。

测试demo

```java
public class WaitThreadDemo_1 {
    public static void main(String[] args) {
        String newString = new String("");

        try {
            newString.wait();
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}
```

运行这段代码，结果抛出异常

```text
Exception in thread "main" java.lang.IllegalMonitorStateException
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:502)
	at waitandnotifythread.WaitThreadDemo_1.main(WaitThreadDemo_1.java:8)
```

这是因为在 Object 类中，wait 底层实现是一个 native 方法

```java
public class Object {
    /**
    * IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
    * @param timeout
    * @throws InterruptedException
    */
    public final native void wait(long timeout) throws InterruptedException;
}
```

异常注释翻译一下就是抛出 IllegalMonitorStateException 是因为 wait 在 JVM 通过 monitor 对象完成，main 方法执行的时候并没有获取到 String 对象的
monitor。

修改代码如下: 

```java
public class WaitThreadDemo_2 {
    public static void main(String[] args) {
        String lock = new String("");
        System.out.println("未获取 String 对象的 monitor 对象");
        synchronized(lock){
        try {
            System.out.println("获取到 String monitor 对象, 执行 wait 方法");
            lock.wait();
            System.out.println("执行 wait 方法后，是否能打印此行日志");
            } catch(InterruptedException e){
                // doNothing
            }
        }
    }
}
```

代码输出结果:

```text
未获取 String 对象的 monitor 对象
获取到 String monitor 对象, 执行 wait 方法

```

程序一直阻塞，并没有继续向下执行。如果要使处于 wait 状态的线程继续运行，就需要使用 notify 方法。demo 如下:

```java
public class WaitNotifyDemo {

    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    System.out.println("T1 start wait time = " + System.currentTimeMillis());
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        // doNothing
                    }
                    System.out.println("T1 end wait time = " + System.currentTimeMillis());
                }
            }
        }, "T1");

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    lock.notify();
                    System.out.println("T2 weak up T1 time = " + System.currentTimeMillis());
                }
            }
        }, "T2");

        t1.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }

        t2.start();
    }
}
```

创建两个线程, 对同一个对象上锁，t1 调用 wait 方法阻塞并释放锁，t2 调用 notify 通知线程 t1 并重新获取锁。这里需要注意的是 t1 获取锁是在 t2 线程执行完
成之后才可以获取 lock 对象锁。看下运行结果:

```text
T1 start wait time = 1656513516636
T2 weak up T1 time = 1656513519637
T1 end wait time = 1656513519637
```

# 生产者/消费者模式的实现

wait/notify 模式最经典的案例就是生产者/消费者模式。基于此模式还衍生出几种变形。来看下

## 一生产/一消费：操作值

```java
public class WaitNotifyProducerConsumer {
    private static final Object lock = new Object();

    private static AtomicInteger count = new AtomicInteger();

    public static void main(String[] args) {
        Thread producer = new Thread(new Runnable() {
            public void run() {
                synchronized(lock){
                    System.out.println("生产者开始生产数字 count = " + count.incrementAndGet());
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        // doNothing
                    }
                }
            }
        }, "producer");


        Thread consumer = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    System.out.println("消费者开始消费数字 count = " + count.decrementAndGet());
                    lock.notify();
                }
            }
        }, "consumer");

        producer.start();
        consumer.start();
    }
}
```

创建两个线程，一个线程对 count 加一，一个减一。运行结果：

```text
生产者开始生产数字 count = 1
消费者开始消费数字 count = 0
```

## 一生产/一消费： 操作栈

创建操作栈方法：

```java
public class MyStack {
    private List<String> stackList = new ArrayList<String>();

    synchronized public void pushStack() {
        if (stackList.size() == 1) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                // doNothing
            }
        }
        stackList.add("anyString= " + Math.random());
        this.notify();
        System.out.println("push= " + stackList.size());
    }

    synchronized public void popStack() {
        if (stackList.size() == 0) {
            System.out.println("pop 操作中的 " + Thread.currentThread().getName() + " 线程状态处于 wait 状态 ！！！");
            try {
                this.wait();
            } catch (InterruptedException e) {
                // doNothing
            }
        }
        stackList.remove(0);
        this.notify();
        System.out.println("pop= " + stackList.size());
    }
}
```

当pushStack 方法 当集合 stackList 大小为 1， 线程开始阻塞等待消费者线程消费; 当集合 stackList 大小为 0，消费者线程开始阻塞，等生产者线程生产；

创建生产者消费者线程

```java
public class ConsumerThread implements Runnable {

    private MyStack myStack;

    public ConsumerThread(){}

    public ConsumerThread(MyStack myStack){
        this.myStack = myStack;
    }

    public void run() {
        while (true) {
            myStack.popStack();
        }
    }
}

public class ProducerThread implements Runnable {

    private MyStack myStack;

    public ProducerThread(MyStack myStack){
        this.myStack = myStack;
    }

    @Override
    public void run() {
        while (true) {
            myStack.pushStack();
        }
    }
}
```

生产者调用 pushStack 方法向集合中填加数据, 消费者调用 popStack 方法移除数据;

测试程序:

```java
public class WaitNotifyProducerConsumerOperateStackDemo {
    public static void main(String[] args) {
        MyStack myStack = new MyStack();

        ConsumerThread consumerThread = new ConsumerThread(myStack);
        ProducerThread producerThread = new ProducerThread(myStack);

        Thread c_Thread = new Thread(consumerThread);
        Thread p_Thread = new Thread(producerThread);

        c_Thread.setName("c_Thread");
        p_Thread.setName("p_Thread");

        p_Thread.start();
        c_Thread.start();
    }
}
```

运行程序结果:

```text
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！

……

```

## 一生产/多消费者：操作栈

基于 MyStack 修改判断方式, while， 使用 if 判断, 消费者不能及时感知条件 stackList 容量等于 1，导致多个消费线程同时唤醒，最终导致移除 stackList
集合元素抛出异常。所以需要将 if 条件改为 while。

测试demo

```java
public class WaitNotifyProducerConsumerOperateStackDemo_2 {
    public static void main(String[] args) throws InterruptedException {
        MyStack_2 myStack_2 = new MyStack_2();

        ConsumerThread_2 consumerThread_2A = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2B = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2C = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2D = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2E = new ConsumerThread_2(myStack_2);

        ProducerThread_2 producerThread_2 = new ProducerThread_2(myStack_2);

        Thread c_ThreadA = new Thread(consumerThread_2A);
        Thread c_ThreadB = new Thread(consumerThread_2B);
        Thread c_ThreadC = new Thread(consumerThread_2C);
        Thread c_ThreadD = new Thread(consumerThread_2D);
        Thread c_ThreadE = new Thread(consumerThread_2E);


        Thread p_Thread = new Thread(producerThread_2);

        c_ThreadA.setName("c_ThreadA");
        c_ThreadB.setName("c_ThreadB");
        c_ThreadC.setName("c_ThreadC");
        c_ThreadD.setName("c_ThreadD");
        c_ThreadE.setName("c_ThreadE");

        p_Thread.setName("p_ThreadA");


        c_ThreadA.start();
        c_ThreadB.start();
        c_ThreadC.start();
        c_ThreadD.start();
        c_ThreadE.start();

        p_Thread.start();
        
        Thread.sleep(5000);
        Thread[] threads = new Thread[Thread.currentThread().getThreadGroup().activeCount()];
        Thread.currentThread().getThreadGroup().enumerate(threads);
        
        for(Thread thread : threads){
            System.out.println(thread.getName() + " " + thread.getState());
        }
    }
}
```

运行结果：

```text
c_ThreadA pop 操作中的 c_ThreadA 线程状态处于 wait 状态 ！！！
c_ThreadD pop 操作中的 c_ThreadD 线程状态处于 wait 状态 ！！！
c_ThreadC pop 操作中的 c_ThreadC 线程状态处于 wait 状态 ！！！
c_ThreadB pop 操作中的 c_ThreadB 线程状态处于 wait 状态 ！！！
p_ThreadA push= 1
c_ThreadE pop= 0
c_ThreadE pop 操作中的 c_ThreadE 线程状态处于 wait 状态 ！！！
c_ThreadD pop 操作中的 c_ThreadD 线程状态处于 wait 状态 ！！！
c_ThreadA pop 操作中的 c_ThreadA 线程状态处于 wait 状态 ！！！
main RUNNABLE
Monitor Ctrl-Break RUNNABLE
c_ThreadA WAITING
c_ThreadB WAITING
c_ThreadC WAITING
c_ThreadD WAITING
c_ThreadE WAITING
p_ThreadA WAITING
```

运行程序后会发现，线程处于 WAIT 状态即"假死"状态，这是因为生产者停止生产后，消费者在消费完第一个数据后，后面启动的生产者直接阻塞，造成程序 "假死"。
使用 notifyAll 无论消费者还是生产者都唤醒，从而使程序继续运行。

# 通过管道进行线程间通信

Java 语言中提供了各种各样的输入流，可以让我们能够很方便的对数据进行操作。其中管道流是一种特殊的流, 用于在不同的线程间直接传递数据


## 字节流

创建写入 demo

```java
public class WriteData {
    public void writeMethod(PipedOutputStream out){
        System.out.println("write : ");
        for(int i=0; i<300; i++){
            String outData = "" + (i+1);
            try {
                out.write(outData.getBytes());
                System.out.print(outData);
            } catch (IOException e) {
                // doNothing
            }
        }
        System.out.println();
        try {
            out.close();
        } catch (IOException e) {
            // doNothing
        }
    }
}
```

循环向管道中写入 300 个字符。

创建读取 demo 

```java
public class ReadData {
    public void readMethod(PipedInputStream pipedInputStream){
        System.out.println("read   ;");
        byte[] byteArray = new byte[20];
        try {
            int readLength = pipedInputStream.read(byteArray);
            while(readLength != -1){
                String newData = new String(byteArray, 0, readLength);
                System.out.print("read : " + newData + " ");
                readLength = pipedInputStream.read(byteArray);
            }
            System.out.println();
            pipedInputStream.close();
        } catch (IOException e) {
            // doNothing
        }
    }
}
```

当读取到管道中没有需要读取的字节，pipedInputStream.read 将返回 -1。

创建 读写线程

```java
public class WriteThread implements Runnable {

    private WriteData writeData;
    private PipedOutputStream outputStream;


    public WriteThread(WriteData writeData, PipedOutputStream outputStream) {
        this.writeData = writeData;
        this.outputStream = outputStream;
    }

    @Override
    public void run() {
        writeData.writeMethod(outputStream);
    }
}

public class ReadThread implements Runnable{

    private ReadData readData;
    private PipedInputStream inputStream;


    public ReadThread(ReadData readData, PipedInputStream inputStream) {
        this.readData = readData;
        this.inputStream = inputStream;
    }

    @Override
    public void run() {
        readData.readMethod(inputStream);
    }
}
```

测试 demo 

```java
public class WriteReadThreadDemo {
    public static void main(String[] args) {
        ReadData readData = new ReadData();
        WriteData writeData = new WriteData();

        PipedInputStream pipedInputStream = new PipedInputStream();
        PipedOutputStream pipedOutputStream = new PipedOutputStream();

        try {
            pipedInputStream.connect(pipedOutputStream);
            //pipedOutputStream.connect(pipedInputStream);

            ReadThread readThread = new ReadThread(readData, pipedInputStream);
            Thread r_Thread = new Thread(readThread);
            r_Thread.start();

            WriteThread writeThread = new WriteThread(writeData, pipedOutputStream);
            Thread w_Thread = new Thread(writeThread);
            w_Thread.start();


        } catch (IOException e) {
            // doNothing
        }
    }
}
```
pipedInputStream.connect(pipedOutputStream); 或者 pipedOutputStream.connect(pipedInputStream); 的作用是是两个管道之间建立连接，
这样才可以对数据进行输入输出

结果如下:

```text
read   ;
write : 
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300
read : 12345678910111213141 read : 51617181920212223242 read : 52627282930313233343 read : 53637383940414243444 read : 54647484950515253545 read : 55657585960616263646 read : 56667686970717273747 read : 57677787980818283848 read : 58687888990919293949 read : 59697989910010110210 read : 31041051061071081091 read : 10111112113114115116 read : 11711811912012112212 read : 31241251261271281291 read : 30131132133134135136 read : 13713813914014114214 read : 31441451461471481491 read : 50151152153154155156 read : 15715815916016116216 read : 31641651661671681691 read : 70171172173174175176 read : 17717817918018118218 read : 31841851861871881891 read : 90191192193194195196 read : 19719819920020120220 read : 32042052062072082092 read : 10211212213214215216 read : 21721821922022122222 read : 32242252262272282292 read : 30231232233234235236 read : 23723823924024124224 read : 32442452462472482492 read : 50251252253254255256 read : 25725825926026126226 read : 32642652662672682692 read : 70271272273274275276 read : 27727827928028128228 read : 32842852862872882892 read : 90291292293294295296 read : 297298299300 
```

## 字符流

与字节流不同的是字符流使用了缓冲区。需要等到输出流关闭才能读取，或者手动 flush 刷到管道中。

读写demo

```java
public class PipeCharReadStream {
    public void readMethod(PipedReader input){
        System.out.print("read: ");
        char[] byteArray = new char[20];
        try {
            int readLength =  input.read(byteArray);
            while(readLength != -1){
                String newData = new String(byteArray, 0, readLength);
                System.out.print(newData);
                readLength = input.read(byteArray);
            }
            System.out.println();
        } catch (IOException e) {
            // doNothing
        }finally {
            try {
                input.close();
            } catch (IOException e) {
                // doNothing
            }
        }
    }
}

public class PipeCharWriteStream {
    public void writeMethod(PipedWriter out){
        System.out.print("write: ");
        for(int i=0; i<300; i++){
            String outData = "" + (i+1);
            try {
                out.write(outData);
            } catch (IOException e) {
                // doNothing
            }
            System.out.print(outData);
        }
        System.out.println();
        try {
            out.close();
        } catch (IOException e) {
            // doNothing
        }
    }
}
```

读写线程

```java
public class PipeReaderThread implements Runnable {

    private PipeCharReadStream pipeCharReadStream;
    private PipedReader pipedReader;

    public PipeReaderThread(PipeCharReadStream pipeCharReadStream, PipedReader pipedReader) {
        this.pipeCharReadStream = pipeCharReadStream;
        this.pipedReader = pipedReader;
    }

    @Override
    public void run() {
        pipeCharReadStream.readMethod(pipedReader);
    }
}

public class PipeWriteThread implements Runnable {

    private PipeCharWriteStream pipeCharWriteStream;
    private PipedWriter pipedWriter;

    public PipeWriteThread(PipeCharWriteStream pipeCharWriteStream, PipedWriter pipedWriter) {
        this.pipeCharWriteStream = pipeCharWriteStream;
        this.pipedWriter = pipedWriter;
    }

    @Override
    public void run() {
        pipeCharWriteStream.writeMethod(pipedWriter);
    }
}
```

测试demo

```java
public class PipeReaderWriterDemo {
    public static void main(String[] args) throws Exception {
        PipedWriter pipedWriter = new PipedWriter();
        PipeCharWriteStream pipeCharWriteStream = new PipeCharWriteStream();
        PipeWriteThread writeThread = new PipeWriteThread(pipeCharWriteStream,pipedWriter);
        Thread w_Thread = new Thread(writeThread);

        PipedReader pipedReader = new PipedReader();
        PipeCharReadStream pipeCharReadStream = new PipeCharReadStream();
        PipeReaderThread pipeReaderThread = new PipeReaderThread(pipeCharReadStream, pipedReader);
        Thread r_Thread = new Thread(pipeReaderThread);

        // 管道建立连接
        // pipedReader.connect(pipedWriter);
        pipedWriter.connect(pipedReader);

        w_Thread.start();

        Thread.sleep(2000);

        r_Thread.start();
    }
}
```

在使用上两者差别不大。

小结一下两者的区别：

字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的。

字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容

那开发中究竟用字节流好还是用字符流好呢？

在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。

如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。
























