 # wait/notify 机制

线程与线程之间不是独立的个体，彼此是可以互相通信协作的。先来介绍一下 wait/notify 机制。

## wait/notify 机制的原理

拥有相同锁的线程才可以实现 wait/notify 机制

### wait() 方法的基本使用

使用条件: 在使用 wait() 方法之前, 线程必须获得该对象的对象级别锁。这也就意味着只能在同步方法中或者同步代码块中使用此方法。notify 同样如此。

作用：wait() 方法的作用是使当前线程暂停运行, 并释放对象锁。

测试demo

```java
public class WaitThreadDemo_1 {
    public static void main(String[] args) {
        String newString = new String("");

        try {
            newString.wait();
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}
```

运行这段代码，结果抛出异常

```text
Exception in thread "main" java.lang.IllegalMonitorStateException
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:502)
	at waitandnotifythread.WaitThreadDemo_1.main(WaitThreadDemo_1.java:8)
```

这是因为在 Object 类中，wait 底层实现是一个 native 方法

```java
public class Object {
    /**
    * IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
    * @param timeout
    * @throws InterruptedException
    */
    public final native void wait(long timeout) throws InterruptedException;
}
```

异常注释翻译一下就是抛出 IllegalMonitorStateException 是因为 wait 在 JVM 通过 monitor 对象完成，main 方法执行的时候并没有获取到 String 对象的
monitor。

修改代码如下: 

```java
public class WaitThreadDemo_2 {
    public static void main(String[] args) {
        String lock = new String("");
        System.out.println("未获取 String 对象的 monitor 对象");
        synchronized(lock){
        try {
            System.out.println("获取到 String monitor 对象, 执行 wait 方法");
            lock.wait();
            System.out.println("执行 wait 方法后，是否能打印此行日志");
            } catch(InterruptedException e){
                // doNothing
            }
        }
    }
}
```

代码输出结果:

```text
未获取 String 对象的 monitor 对象
获取到 String monitor 对象, 执行 wait 方法

```

程序一直阻塞，并没有继续向下执行。如果要使处于 wait 状态的线程继续运行，就需要使用 notify 方法。demo 如下:

```java
public class WaitNotifyDemo {

    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    System.out.println("T1 start wait time = " + System.currentTimeMillis());
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        // doNothing
                    }
                    System.out.println("T1 end wait time = " + System.currentTimeMillis());
                }
            }
        }, "T1");

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    lock.notify();
                    System.out.println("T2 weak up T1 time = " + System.currentTimeMillis());
                }
            }
        }, "T2");

        t1.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }

        t2.start();
    }
}
```

创建两个线程, 对同一个对象上锁，t1 调用 wait 方法阻塞并释放锁，t2 调用 notify 通知线程 t1 并重新获取锁。这里需要注意的是 t1 获取锁是在 t2 线程执行完
成之后才可以获取 lock 对象锁。看下运行结果:

```text
T1 start wait time = 1656513516636
T2 weak up T1 time = 1656513519637
T1 end wait time = 1656513519637
```

# 生产者/消费者模式的实现

wait/notify 模式最经典的案例就是生产者/消费者模式。基于此模式还衍生出几种变形。来看下

## 一生产/一消费：操作值

```java
public class WaitNotifyProducerConsumer {
    private static final Object lock = new Object();

    private static AtomicInteger count = new AtomicInteger();

    public static void main(String[] args) {
        Thread producer = new Thread(new Runnable() {
            public void run() {
                synchronized(lock){
                    System.out.println("生产者开始生产数字 count = " + count.incrementAndGet());
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        // doNothing
                    }
                }
            }
        }, "producer");


        Thread consumer = new Thread(new Runnable() {
            public void run() {
                synchronized (lock){
                    System.out.println("消费者开始消费数字 count = " + count.decrementAndGet());
                    lock.notify();
                }
            }
        }, "consumer");

        producer.start();
        consumer.start();
    }
}
```

创建两个线程，一个线程对 count 加一，一个减一。运行结果：

```text
生产者开始生产数字 count = 1
消费者开始消费数字 count = 0
```

## 一生产/一消费： 操作栈

创建操作栈方法：

```java
public class MyStack {
    private List<String> stackList = new ArrayList<String>();

    synchronized public void pushStack() {
        if (stackList.size() == 1) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                // doNothing
            }
        }
        stackList.add("anyString= " + Math.random());
        this.notify();
        System.out.println("push= " + stackList.size());
    }

    synchronized public void popStack() {
        if (stackList.size() == 0) {
            System.out.println("pop 操作中的 " + Thread.currentThread().getName() + " 线程状态处于 wait 状态 ！！！");
            try {
                this.wait();
            } catch (InterruptedException e) {
                // doNothing
            }
        }
        stackList.remove(0);
        this.notify();
        System.out.println("pop= " + stackList.size());
    }
}
```

当pushStack 方法 当集合 stackList 大小为 1， 线程开始阻塞等待消费者线程消费; 当集合 stackList 大小为 0，消费者线程开始阻塞，等生产者线程生产；

创建生产者消费者线程

```java
public class ConsumerThread implements Runnable {

    private MyStack myStack;

    public ConsumerThread(){}

    public ConsumerThread(MyStack myStack){
        this.myStack = myStack;
    }

    public void run() {
        while (true) {
            myStack.popStack();
        }
    }
}

public class ProducerThread implements Runnable {

    private MyStack myStack;

    public ProducerThread(MyStack myStack){
        this.myStack = myStack;
    }

    @Override
    public void run() {
        while (true) {
            myStack.pushStack();
        }
    }
}
```

生产者调用 pushStack 方法向集合中填加数据, 消费者调用 popStack 方法移除数据;

测试程序:

```java
public class WaitNotifyProducerConsumerOperateStackDemo {
    public static void main(String[] args) {
        MyStack myStack = new MyStack();

        ConsumerThread consumerThread = new ConsumerThread(myStack);
        ProducerThread producerThread = new ProducerThread(myStack);

        Thread c_Thread = new Thread(consumerThread);
        Thread p_Thread = new Thread(producerThread);

        c_Thread.setName("c_Thread");
        p_Thread.setName("p_Thread");

        p_Thread.start();
        c_Thread.start();
    }
}
```

运行程序结果:

```text
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！
push= 1
pop= 0
pop 操作中的 c_Thread 线程状态处于 wait 状态 ！！！

……

```

## 一生产/多消费者：操作栈

基于 MyStack 修改判断方式, while， 使用 if 判断, 消费者不能及时感知条件 stackList 容量等于 1，导致多个消费线程同时唤醒，最终导致移除 stackList
集合元素抛出异常。所以需要将 if 条件改为 while。

测试demo

```java
public class WaitNotifyProducerConsumerOperateStackDemo_2 {
    public static void main(String[] args) throws InterruptedException {
        MyStack_2 myStack_2 = new MyStack_2();

        ConsumerThread_2 consumerThread_2A = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2B = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2C = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2D = new ConsumerThread_2(myStack_2);
        ConsumerThread_2 consumerThread_2E = new ConsumerThread_2(myStack_2);

        ProducerThread_2 producerThread_2 = new ProducerThread_2(myStack_2);

        Thread c_ThreadA = new Thread(consumerThread_2A);
        Thread c_ThreadB = new Thread(consumerThread_2B);
        Thread c_ThreadC = new Thread(consumerThread_2C);
        Thread c_ThreadD = new Thread(consumerThread_2D);
        Thread c_ThreadE = new Thread(consumerThread_2E);


        Thread p_Thread = new Thread(producerThread_2);

        c_ThreadA.setName("c_ThreadA");
        c_ThreadB.setName("c_ThreadB");
        c_ThreadC.setName("c_ThreadC");
        c_ThreadD.setName("c_ThreadD");
        c_ThreadE.setName("c_ThreadE");

        p_Thread.setName("p_ThreadA");


        c_ThreadA.start();
        c_ThreadB.start();
        c_ThreadC.start();
        c_ThreadD.start();
        c_ThreadE.start();

        p_Thread.start();
        
        Thread.sleep(5000);
        Thread[] threads = new Thread[Thread.currentThread().getThreadGroup().activeCount()];
        Thread.currentThread().getThreadGroup().enumerate(threads);
        
        for(Thread thread : threads){
            System.out.println(thread.getName() + " " + thread.getState());
        }
    }
}
```

运行结果：

```text
c_ThreadA pop 操作中的 c_ThreadA 线程状态处于 wait 状态 ！！！
c_ThreadD pop 操作中的 c_ThreadD 线程状态处于 wait 状态 ！！！
c_ThreadC pop 操作中的 c_ThreadC 线程状态处于 wait 状态 ！！！
c_ThreadB pop 操作中的 c_ThreadB 线程状态处于 wait 状态 ！！！
p_ThreadA push= 1
c_ThreadE pop= 0
c_ThreadE pop 操作中的 c_ThreadE 线程状态处于 wait 状态 ！！！
c_ThreadD pop 操作中的 c_ThreadD 线程状态处于 wait 状态 ！！！
c_ThreadA pop 操作中的 c_ThreadA 线程状态处于 wait 状态 ！！！
main RUNNABLE
Monitor Ctrl-Break RUNNABLE
c_ThreadA WAITING
c_ThreadB WAITING
c_ThreadC WAITING
c_ThreadD WAITING
c_ThreadE WAITING
p_ThreadA WAITING
```

运行程序后会发现，线程处于 WAIT 状态即"假死"状态，这是因为生产者停止生产后，消费者在消费完第一个数据后，后面启动的生产者直接阻塞，造成程序 "假死"。
使用 notifyAll 无论消费者还是生产者都唤醒，从而使程序继续运行。

## 连续生产/连续消费

















