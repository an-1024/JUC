# 定时器 Timer 的使用

在 JDK 库中 Timer 类主要负责计划任务的功能。即指定任务在指定的时间运行。

## 方法 schedule(TimerTask task, Date time) 的使用

该方法的作用是在指定的日期执行一次某一任务。

创建任务类:

```java
public class MyTask extends TimerTask {
    @Override
    public void run() {
        System.out.println("任务执行了, 时间为: " + System.currentTimeMillis());
    }
}
```

创建测试类：

```java
public class MyTaskTest {
    public static void main(String[] args) {
        long nowTime = System.currentTimeMillis();
        System.out.println("当前时间为：" + nowTime);

        long scheduleTime = (nowTime + 10000);
        System.out.println("计划时间为: " + scheduleTime);

        MyTask task = new MyTask();

        Timer timer = new Timer();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // doNothing
        }
        timer.schedule(task, new Date(scheduleTime));

        try {
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}
```

程序运行结果：

```text
当前时间为：1659109487469
计划时间为: 1659109497469
任务执行了, 时间为: 1659109497472
```

10s 之后任务执行成功，但是进程还未销毁。这是因为在创建 Timer 对象时，启动了一个新的非守护线程。JDK 源码如下:

```java
public class Timer {
    public Timer(String name) {
        thread.setName(name);
        thread.start();
    }
}
```

这个 thread 变量是 TimerThread 线程类。该类继承了 Thread 类，thread.start() 启动时会执行 TimerThread 类中重写的 run() 方法：

```java
public class Timer {
    public void run() {
        try {
            mainLoop();
        } finally {
            // Someone killed this Thread, behave as if Timer cancelled
            synchronized (queue) {
                newTasksMayBeScheduled = false;
                queue.clear();  // Eliminate obsolete references
            }
        }
    }
}
```
而导致线程一直循环的是 mainLoop() 方法。 而这个方法的源码如下:

```java
public class Timer {
    /**
     * The main timer loop.  (See class comment.)
     */
    private void mainLoop() {
        // 死循环一直执行计划任务，并不退出 while(true) 死循环
        while (true) {
            try {
                TimerTask task;
                boolean taskFired;
                synchronized(queue) {
                    // Wait for queue to become non-empty
                    // 1.当 queue 和 newTasksMayBeScheduled 都为 true 时，才会使当前线程停止运行
                    // 等待被唤醒
                    while (queue.isEmpty() && newTasksMayBeScheduled)
                        queue.wait();
                    // 再次判断任务队列是否为 null，为 null 退出循环
                    if (queue.isEmpty())
                        break; // Queue is empty and will forever remain; die

                    // Queue nonempty; look at first evt and do the right thing
                    long currentTime, executionTime;
                    task = queue.getMin();
                    synchronized(task.lock) {
                        if (task.state == TimerTask.CANCELLED) {
                            queue.removeMin();
                            continue;  // No action required, poll queue again
                        }
                        currentTime = System.currentTimeMillis();
                        executionTime = task.nextExecutionTime;
                        if (taskFired = (executionTime<=currentTime)) {
                            if (task.period == 0) { // Non-repeating, remove
                                queue.removeMin();
                                task.state = TimerTask.EXECUTED;
                            } else { // Repeating task, reschedule
                                queue.rescheduleMin(
                                        task.period<0 ? currentTime   - task.period
                                                : executionTime + task.period);
                            }
                        }
                    }
                    if (!taskFired) // Task hasn't yet fired; wait
                        queue.wait(executionTime - currentTime);
                }
                if (taskFired)  // Task fired; run it, holding no locks
                    task.run();
            } catch(InterruptedException e) {
            }
        }
    }
}
```
 其中代码中 newTasksMayBeScheduled 置为 false 是在 cancel 方法中。源码如下：

```java
public class Timer {
    public void cancel() {
        synchronized (queue) {
            thread.newTasksMayBeScheduled = false;
            queue.clear();
            queue.notify();  // In case queue was already empty.
        }
    }
}
```

以上就是进程不销毁的原因，以及退出死循环 while(true) 的逻辑。

## 使用 public void cancel() 方法实现线程 TimerThread 销毁

