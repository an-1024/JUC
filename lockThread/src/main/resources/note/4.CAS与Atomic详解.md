# CAS

> 什么是 CAS：
>
> CAS(Compare and Swap 比较并交换)：它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是原子的。
>
> CAS 是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。

# CAS 的使用-Unsafe 类

CAS 是 CPU 级别支持的指令，在 Java 中 JVM 封装了 CAS 相关的 API供我们直接使用——Unsafe 类。这个类提供了一些针对 CAS 操作指令的方法。

```java
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);

public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);

public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
```

上述方法都是被 native 修饰。也就意味着具体的实现不在 Java 当中。

在 JVM 的源码中的实现在 hotspot\src\share\vm\prims\unsafe.cpp 文件下，摘取部分代码

```c++
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h))
  UnsafeWrapper("Unsafe_CompareAndSwapObject");
  oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, true);
  return success;
UNSAFE_END

UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt");
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END

UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))
  UnsafeWrapper("Unsafe_CompareAndSwapLong");
  if (VM_Version::supports_cx8())
    return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;
  else {
  }
UNSAFE_END
```

根据 native 名称在 jni.h 方法名称映射，找到在 C++ 中的方法实现，可以看到都调用了 Atomic::cmpxchg 的方法(部分代码，AMD 的实现)。针对不同类型有对应的方法实现：

```c++
// Add a lock prefix to an instruction on an MP machine
#define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "

inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}

inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {
  bool mp = os::is_MP();
  __asm__ __volatile__ (LOCK_IF_MP(%4) "cmpxchgq %1,(%3)"
                        : "=a" (exchange_value)
                        : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                        : "cc", "memory");
  return exchange_value;
}
```

> volatile 在 C、C++ 中表示不允许编译器进行优化。避免编译器对指令进行重排造成不可知的问题，以及保证每次修改变量完成之后必须将更新后的值刷入内存中。
>
> LOCK_IF_MP(mp): 宏定义了 CPU 的操作指令，注意它的说明：在 MP 机器上为指令添加**锁**前缀，如果当前系统为多核 CPU 的时候。所以可以看到 CAS 也是需要加锁的，这个锁是锁定的北桥信号，并不是总线。

为什么要加锁呢？因为 cmpxchg 在CPU级别并不是原子操作，来看一下这个图：

![](/Users/azh/Dev_AZH/Java_St/JUC/lockThread/src/main/resources/photo/3.cmpxchg指令非原子操作.png)



在高并发下，就会存在如上图这样一个场景，A线程在更新0所在内存地址值的时候，B线程将0修改为2，接着线程 A 开始写入，发现与原来的旧值不等，结果将原来的旧值 0 又写入内存。因此在多核下才会在  cmpxchg 加一个 lock 前缀，进行加锁操作。

# CAS 的使用-java.util.concurrent.atomic包

在 Java 的 atomic 包下提供了针对基础类型以及对对象的操作API。通过对 Unsafe 类的封装提供并扩展了一些 API 操作。

```java
// setup to use Unsafe.compareAndSwapInt for updates
private static final Unsafe unsafe = Unsafe.getUnsafe();
public final int getAndAdd(int delta) {
  return unsafe.getAndAddInt(this, valueOffset, delta);
}
// 在 unsafe 中通过自旋的方式实现
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
    var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

  return var5;
}

public final int getAndSet(int newValue) {
  return unsafe.getAndSetInt(this, valueOffset, newValue);
}
// 在 Unsafe 中的实现
public final int getAndSetInt(Object var1, long var2, int var4) {
  int var5;
  do {
    var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var4));

  return var5;
}
```

通过这几个 API 的实现，就可以明白为什么称 CAS 在 Java 层面是无锁操作了。都是通过自旋来达到对数或者数组以及对象的操作。

# CAS 的问题

虽然 CAS 相比于 synchronized 性能更加突出，但是随之而来的也会产生以下几个问题：

## ABA问题：

![](/Users/azh/Dev_AZH/Java_St/JUC/lockThread/src/main/resources/photo/4.CAS-ABA问题.png)



代码复现一下：

```java
public class CASABADemo {
    private static AtomicInteger at = new AtomicInteger(1);
    public static void main(String[] args) throws InterruptedException {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                int i = at.get();
                System.out.println("线程A读取初始值：" + i);//1
                //比较并交换,将at的值从1修改为2
                at.compareAndSet(at.get(), 2);
            }
        }, "A线程");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //线程B调用线程A的join方法，线程B会阻塞直到线程A执行完毕。
                    threadA.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int i = at.get();
                System.out.println("线程B读取初始值：" + i);//1
                //比较并交换，将at的值由2修改回1
                at.compareAndSet(i, 1);
            }
        }, "B线程");

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //线程B调用线程B的join方法，线程B会阻塞直到线程B执行完毕。
                    threadB.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int i = at.get();
                System.out.println("线程C读取初始值：" + i);//1
                //比较并交换，将at的值由1修改回2
                boolean result = at.compareAndSet(i, 2);
                System.out.println("线程C比较并修改at的值的执行结果-> "+result);
            }
        }, "C线程");

        //启动线程
        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```

输出结果：

```java
线程A读取初始值：1
线程B读取初始值：2
线程C读取初始值：1
线程C比较并修改at的值的执行结果-> true
```

可以看到 C 线程并没有感知到，此时的 1 已经经过修改了。

实际带来的危害：比如在银行存款取款的过程中，原账户有 100 元，此时有两个线程同时执行取款操作，取款 50 元，线程 A 执行成功了，但是线程 B 由于某些原因阻塞了，此时又有一个线程执行存款操作，刚好也是存款 50 元，执行成功后，此时线程 B 开始执行，虽然最终账户显示是 50 元，但是线程 B 明显是非法操作，可能是别人在用你的卡取钱，你都不知道你朋友给你打了 50 元的伙食费，还以为是自己取了 50 元。这个明显是有问题的。

为了解决这个问题，JDK 提供了AtomicStampedReference 解决 ABA 问题。

```java
/**
 * CAS ABA 问题解决
 */
public class CASABASolutionDemo {
    private static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(10, 1);
    public static void main(String[] args) {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("线程A拿到当前初始时间戳版本号为：" + atomicStampedReference.getStamp());
                //比较并交换,将值从 10 设置为 11
                atomicStampedReference.compareAndSet(10, 11, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
                System.out.println("线程A拿到当前时间戳版本号为：" + atomicStampedReference.getStamp());
            }
        }, "A线程");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //线程B调用线程A的join方法，线程B会阻塞直到线程A执行完毕。
                    threadA.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程B拿到当前初始时间戳版本号为：" + atomicStampedReference.getStamp());
                //比较并交换,将值从 11 设置为 10
                atomicStampedReference.compareAndSet(11, 10, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
                System.out.println("线程B拿到当前时间戳版本号为：" + atomicStampedReference.getStamp());
            }
        }, "B线程");

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //线程B调用线程B的join方法，线程B会阻塞直到线程B执行完毕。
                    threadB.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程C拿到当前初始时间戳版本号为：" + atomicStampedReference.getStamp());
                //比较并交换,将值从 10 设置为 11
                atomicStampedReference.compareAndSet(10, 11, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
                System.out.println("线程C拿到当前时间戳版本号为：" + atomicStampedReference.getStamp());
            }
        }, "C线程");

        //启动线程
        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```

输出结果：

```txt
线程A拿到当前初始时间戳版本号为：1
线程A拿到当前时间戳版本号为：2
线程B拿到当前初始时间戳版本号为：2
线程B拿到当前时间戳版本号为：3
线程C拿到当前初始时间戳版本号为：3
线程C拿到当前时间戳版本号为：4
```

根据结果可以看出加上版本号之后，就可以区分每个过程的操作。

## 自旋时间过长的问题：

高并发下，自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。

1. 从自旋次数入手，破坏循环，限定循环次数；

2. 使用类似ConcurrentHashMap的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来，能降低CPU消耗。比如 LongAdder。将变量值分散放到 Cell[] 数组中，各个线程只需要操作自己对应槽中的值，如果要获取正真的值，最终求和即可。这个就是分散热点的思想。

3. 利用 JVM 的 pause 指令，通过让渡 CPU 资源给其他线程提升整体运算效率。另一方面，由于线程的让渡，避免了竞争，减少了对共享内存的访问，提升其他线程的效率。

   > pause指令最主要的作用是减低功耗和延迟执行下一条指令。所以我们可以有这样的猜想：如果在spin-wait的过程中，记录下加锁失败的次数，对失败的加锁行为进行惩罚(failure penalty)，让等待时间和失败次数成正比，即失败次数越多等待时间越长、执行的pause指令越多。

## CAS 的缺点

>  **CAS只能单变量对于一个共享变量，可以使用CAS方式来保证原子操作，但是当多个共享变量时，那就无法使用CAS来保证原子性**。JDK1.5开始，提供了AtomicReference类来保证引用对象之前的原子性，就可以把多个变量放在一个对象里来进行CAS操作。