# 如何实现一把独占锁

>state：首先要有一个表示锁状态的字段，如 0 无锁，1 有锁。
>
>那么在多线程中如何操作 state 呢？ 我们前面提到过的 CAS。接下的问题是抢锁失败的线程怎么处理呢？

> 等待队列(queue)：存储抢锁失败的线程的数据；
>
> 那么如何让这队列中的线程继续执行呢？这就需要额外的唤醒机制。

> 等待唤醒：比如 JDK 中实现的 wait()/notify() 、LockSupport.park()/unpark() 等

> 其次是一些共性的操作：入口等待队列、条件等待队列、入队出队等操作。针对这些共性操作，可以定义一个抽象类，在抽象类中定义共性的方法，然后交由子类实现。(设计模式：模版方法)

下面介绍的 AQS 基本上就是以上述逻辑实现的。

# 什么是 AQS

AQS 即 AbstractQueuedSynchronizer。**队列同步器，它是Java并发用来构建锁和其他同步组件的基础框架**。

可以看下在这个抽象类中实现了那些方法(部分)。

```java
private volatile int state;

protected final int getState() {
  return state;
}

public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
}

protected boolean tryAcquire(int arg) {
  throw new UnsupportedOperationException();
}
```

# AQS 具备的特性

> 1.  阻塞等待队列；
> 2. 共享/独占；
> 3. 公平/非公平；
> 4. 可重入；
> 5. 允许中断；

## 独占锁实现

