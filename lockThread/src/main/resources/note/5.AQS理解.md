# å¦‚ä½•å®ç°ä¸€æŠŠç‹¬å é”

>stateï¼šé¦–å…ˆè¦æœ‰ä¸€ä¸ªè¡¨ç¤ºé”çŠ¶æ€çš„å­—æ®µï¼Œå¦‚ 0 æ— é”ï¼Œ1 æœ‰é”ã€‚
>
>é‚£ä¹ˆåœ¨å¤šçº¿ç¨‹ä¸­å¦‚ä½•æ“ä½œ state å‘¢ï¼Ÿ æˆ‘ä»¬å‰é¢æåˆ°è¿‡çš„ CASã€‚æ¥ä¸‹çš„é—®é¢˜æ˜¯æŠ¢é”å¤±è´¥çš„çº¿ç¨‹æ€ä¹ˆå¤„ç†å‘¢ï¼Ÿ

> ç­‰å¾…é˜Ÿåˆ—(queue)ï¼šå­˜å‚¨æŠ¢é”å¤±è´¥çš„çº¿ç¨‹çš„æ•°æ®ï¼›
>
> é‚£ä¹ˆå¦‚ä½•è®©è¿™é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹ç»§ç»­æ‰§è¡Œå‘¢ï¼Ÿè¿™å°±éœ€è¦é¢å¤–çš„å”¤é†’æœºåˆ¶ã€‚

> ç­‰å¾…å”¤é†’ï¼šæ¯”å¦‚ JDK ä¸­å®ç°çš„ wait()/notify() ã€LockSupport.park()/unpark() ç­‰

> å…¶æ¬¡æ˜¯ä¸€äº›å…±æ€§çš„æ“ä½œï¼šå…¥å£ç­‰å¾…é˜Ÿåˆ—ã€æ¡ä»¶ç­‰å¾…é˜Ÿåˆ—ã€å…¥é˜Ÿå‡ºé˜Ÿç­‰æ“ä½œã€‚é’ˆå¯¹è¿™äº›å…±æ€§æ“ä½œï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œåœ¨æŠ½è±¡ç±»ä¸­å®šä¹‰å…±æ€§çš„æ–¹æ³•ï¼Œç„¶åäº¤ç”±å­ç±»å®ç°ã€‚(è®¾è®¡æ¨¡å¼ï¼šæ¨¡ç‰ˆæ–¹æ³•)

åœ¨å®ç°ç‹¬å é”ä¹‹å‰ï¼Œå…ˆäº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯ç®¡ç¨‹æ¨¡å‹ã€‚

## ä»€ä¹ˆæ˜¯ MESA ç®¡ç¨‹æ¨¡å‹ï¼š

åœ¨è§£å†³å¹¶å‘é—®é¢˜çš„æ—¶å€™ï¼Œæœ€æ—©ä½¿ç”¨çš„æ˜¯ä¿¡å·é‡ã€‚åˆ°åé¢æ‰æ˜¯ç®¡ç¨‹æ¨¡å‹çš„æå‡ºã€‚é‚£ä¹ˆè¿™ä¸¤ä¸ªæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

### ä¿¡å·é‡(semaphore)

ä¿¡å·é‡åˆç§°ä¸ºä¿¡å·æ ‡ã€‚**æ˜¯ä¸€ä¸ªåŒæ­¥å¯¹è±¡ï¼Œç”¨äºä¿æŒåœ¨0è‡³æŒ‡å®šæœ€å¤§å€¼ä¹‹é—´çš„ä¸€ä¸ªè®¡æ•°å€¼**ã€‚ å½“çº¿ç¨‹å®Œæˆä¸€æ¬¡å¯¹è¯¥semaphoreå¯¹è±¡çš„ç­‰å¾…ï¼ˆwaitï¼‰æ—¶ï¼Œè¯¥è®¡æ•°å€¼å‡ä¸€ï¼›å½“çº¿ç¨‹å®Œæˆä¸€æ¬¡å¯¹semaphoreå¯¹è±¡çš„é‡Šæ”¾ï¼ˆreleaseï¼‰æ—¶ï¼Œè®¡æ•°å€¼åŠ ä¸€ã€‚

> ä¿¡å·é‡è¿ä½œæ–¹å¼ï¼š
>
> 1. åˆå§‹åŒ–ï¼Œç»™ä¸å®ƒä¸€ä¸ªéè´Ÿæ•°çš„æ•´æ•°å€¼ã€‚
> 2. æ‰§è¡ŒP(wait())ï¼šä¿¡å·æ ‡Sçš„å€¼å°†è¢«å‡å°‘ã€‚ä¼å›¾è¿›å…¥ä¸´ç•ŒåŒºæ®µçš„è¿›ç¨‹ï¼Œéœ€è¦å…ˆæ‰§è¡ŒPï¼ˆ`wait()`ï¼‰ã€‚å½“ä¿¡å·æ ‡Så‡ä¸ºè´Ÿå€¼æ—¶ï¼Œè¿›ç¨‹ä¼šè¢«æŒ¡ä½ï¼Œä¸èƒ½ç»§ç»­ï¼›å½“ä¿¡å·æ ‡Sä¸ä¸ºè´Ÿå€¼æ—¶ï¼Œè¿›ç¨‹å¯ä»¥è·å‡†è¿›å…¥ä¸´ç•ŒåŒºæ®µã€‚
> 3. æ‰§è¡ŒV(signal())ï¼šä¿¡å·æ ‡Sçš„å€¼ä¼šè¢«å¢åŠ ã€‚ç»“æŸç¦»[ä¸´ç•ŒåŒºæ®µçš„è¿›ç¨‹ï¼Œå°†ä¼šæ‰§è¡ŒVï¼ˆ`signal()`ï¼‰ã€‚å½“ä¿¡å·æ ‡Sä¸ä¸ºè´Ÿå€¼æ—¶ï¼Œå…ˆå‰è¢«æŒ¡ä½çš„å…¶ä»–è¿›ç¨‹ï¼Œå°†å¯è·å‡†è¿›å…¥ä¸´ç•ŒåŒºæ®µã€‚
>
> ä¸¾ä¸ªå®é™…çš„ä¾‹å­ï¼š
>
> æˆ‘ä»¬ä¸¾ä¸ªç°å®ä¸­é‡‡ç”¨ä¿¡å·é‡æ§åˆ¶çº¿ç¨‹çš„ä¾‹å­ï¼Œä¾‹å¦‚æˆ‘ä»¬ä¿¡å·é‡è®¾ç½®çš„æ˜¯2ï¼Œä¹Ÿå°±æ˜¯åŒæ—¶åªå…è®¸2ä¸ªçº¿ç¨‹å¤„ç†ï¼Œå½“ç¬¬ä¸‰ä¸ªçº¿ç¨‹ T3 æ¥çš„æ—¶å€™ T1ã€T2 è¿˜æ²¡å¤„ç†å®Œçš„æƒ…å†µä¸‹ï¼ŒT3 ä¼šé˜»å¡åˆ° T1 æˆ– T2 æ‰§è¡Œå®Œæˆå¹¶ä¸”é€šè¿‡ V æ“ä½œ(åŠ 1ï¼Œé‡Šæ”¾ä¸€ä¸ªä½ç½®ç»™åˆ«äºº)ï¼Œè¿™ä¸ªæ—¶å€™ T3 è¿›è¡Œ Pæ“ä½œ(å‡ä¸€ï¼ŒæŠŠè¿™ä¸ªä½ç½®å ç”¨)ã€‚
>
> åŒæ ·çš„å¦‚æœsæˆ‘ä»¬è®¾ç½®ä¸º1ï¼Œåˆ™å¯ä»¥å®ç°çº¿ç¨‹ä¹‹é—´çš„äº’æ–¥æ“ä½œã€‚

### ç®¡ç¨‹(Monitor)

ç®¡ç¨‹ä¹Ÿç§°ä¸ºç›‘è§†å™¨ï¼Œå®ƒæ˜¯ä¸€ç§ç¨‹åºç»“æ„ã€‚ç»“æ„å†…çš„å¤šä¸ªå­ç¨‹åºå½¢æˆçš„å¤šä¸ªå·¥ä½œçº¿ç¨‹äº’æ–¥è®¿é—®å…±äº«èµ„æºã€‚ç®¡ç¨‹å®ç°äº†åœ¨ä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œæœ€å¤šåªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œç®¡ç¨‹çš„æŸä¸ªå­ç¨‹åºã€‚

ç®¡ç¨‹è¿˜æä¾›äº†ä¸€ç§æœºåˆ¶ï¼Œçº¿ç¨‹å¯ä»¥ä¸´æ—¶æ”¾å¼ƒäº’æ–¥è®¿é—®ï¼Œç­‰å¾…æŸäº›æ¡ä»¶å¾—åˆ°æ»¡è¶³åï¼Œé‡æ–°è·å¾—æ‰§è¡Œæƒæ¢å¤å®ƒçš„äº’æ–¥è®¿é—®ã€‚

ç®¡ç¨‹ä¸ä¿¡å·é‡æ˜¯ç­‰ä»·çš„ã€‚

> ä¸€ä¸ªç®¡ç¨‹åŒ…å«çš„å†…å®¹å¦‚ä¸‹ï¼š
>
> 1. å¤šä¸ªå½¼æ­¤å¯ä»¥äº¤äº’å¹¶å…±äº«èµ„æºçš„çº¿ç¨‹ï¼›
> 2. å¤šä¸ªä¸èµ„æºä½¿ç”¨æœ‰å…³çš„å˜é‡ï¼›
> 3. ä¸€ä¸ªäº’æ–¥é”ï¼›
> 4. ä¸€ä¸ªç”¨æ¥é¿å…é™æ€æ¡ä»¶çš„ä¸å˜é‡ï¼›
>
> è¿ä½œæ–¹å¼ï¼š
>
> ä¸€ä¸ªç®¡ç¨‹çš„ç¨‹åºåœ¨æ‰§è¡Œä¸€ä¸ªçº¿ç¨‹å‰ä¼šå…ˆè·å–äº’æ–¥é”ï¼Œç›´åˆ°å®Œæˆçº¿ç¨‹æˆ–æ˜¯çº¿ç¨‹ç­‰å¾…æŸä¸ªæ¡ä»¶è¢«æ»¡è¶³æ‰ä¼šæ”¾å¼ƒäº’æ–¥é”ã€‚è‹¥æ¯ä¸ªæ‰§è¡Œä¸­çš„çº¿ç¨‹åœ¨æ”¾å¼ƒäº’æ–¥é”ä¹‹å‰éƒ½èƒ½ä¿è¯ä¸å˜é‡æˆç«‹ï¼Œåˆ™æ‰€æœ‰çº¿ç¨‹çš†ä¸ä¼šå¯¼è‡´ç«æ€æ¡ä»¶æˆç«‹ã€‚

ç®¡ç¨‹MESAæ¨¡å‹å¦‚ä¸‹ï¼š

![](../photo/5.MESAç®¡ç¨‹æ¨¡å‹.png)

ç®¡ç¨‹è¿˜æœ‰å…¶ä»–ä¸¤ç§æ¨¡å‹ï¼šHasenæ¨¡å‹ã€Hoareæ¨¡å‹ã€‚

> å‡è®¾æœ‰ T1 å’Œ T2 ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºã€‚è¿™ä¸‰ç§æ¨¡å‹å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š
>
> 1. Hasenæ¨¡å‹ï¼šHasenæ¨¡å‹è¦æ±‚notifyæ”¾åˆ°æœ€åï¼Œè¿™æ ·T2çº¿ç¨‹é€šçŸ¥T1åï¼ŒT2çº¿ç¨‹å°±ç»“æŸäº†ï¼Œç„¶åT1æ‰§è¡Œå®Œï¼Œè¿™æ ·å°±èƒ½ä¿è¯åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œã€‚
> 2. Hoareæ¨¡å‹ï¼š Hoareæ¨¡å‹é‡Œé¢ï¼ŒT2çº¿ç¨‹é€šçŸ¥å®ŒT1çº¿ç¨‹åï¼ŒT2é©¬ä¸Šé˜»å¡ï¼ŒT1é©¬ä¸Šæ‰§è¡Œï¼›ç­‰T1æ‰§è¡Œå®Œä¹‹åå†å”¤é†’T2çº¿ç¨‹ï¼Œä¹Ÿèƒ½ä¿è¯åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œï¼Œä½†æ˜¯T2å¤šäº†ä¸€æ¬¡é˜»å¡å”¤é†’æ“ä½œã€‚
> 3. MESAç®¡ç¨‹æ¨¡å‹ï¼ˆJavaä½¿ç”¨MESAæ¨¡å‹å®ç°ï¼‰ï¼š MESAæ¨¡å‹ä¸­ï¼ŒT2å”¤é†’T1ä¹‹åï¼ŒT2è¿˜æ˜¯ä¼šæ¥ç€æ‰§è¡Œï¼ŒT1å¹¶ä¸ç«‹å³æ‰§è¡Œï¼Œä»…ä»…æ˜¯ä»æ¡ä»¶å˜é‡é˜Ÿåˆ—åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ã€‚
>    1.   å¥½å¤„ï¼šnotifyï¼ˆæˆ–notifyAllï¼‰ã€signalï¼ˆæˆ–signalAllï¼‰ä¸ç”¨æ”¾åˆ°ä»£ç çš„æœ€åï¼ŒT2ä¹Ÿæ²¡æœ‰å¤šä½™çš„é˜»å¡å”¤é†’æ“ä½œã€‚
>    2. T1æ‰§è¡Œçš„æ—¶å€™ï¼Œå¯èƒ½æ›¾ç»æ»¡è¶³è¿‡æ¡ä»¶ï¼Œç°åœ¨å·²ç»ä¸èƒ½æ»¡è¶³äº†ï¼Œéœ€è¦å¢åŠ å¾ªç¯éªŒè¯æ¡ä»¶æ–¹å¼ã€‚



# ä»€ä¹ˆæ˜¯ AQS

AQS å³ AbstractQueuedSynchronizerã€‚**é˜Ÿåˆ—åŒæ­¥å™¨ï¼Œå®ƒæ˜¯Javaå¹¶å‘ç”¨æ¥æ„å»ºé”å’Œå…¶ä»–åŒæ­¥ç»„ä»¶çš„åŸºç¡€æ¡†æ¶**ã€‚

å¯ä»¥çœ‹ä¸‹åœ¨è¿™ä¸ªæŠ½è±¡ç±»ä¸­å®ç°äº†é‚£äº›æ–¹æ³•(éƒ¨åˆ†)ã€‚

```java
private volatile int state;

protected final int getState() {
  return state;
}

public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
}

protected boolean tryAcquire(int arg) {
  throw new UnsupportedOperationException();
}
```

# AQS å…·å¤‡çš„ç‰¹æ€§

> 1. Â é˜»å¡ç­‰å¾…é˜Ÿåˆ—ï¼›
> 2. å…±äº«/ç‹¬å ï¼›
> 3. å…¬å¹³/éå…¬å¹³ï¼›
> 4. å¯é‡å…¥ï¼›
> 5. å…è®¸ä¸­æ–­ï¼›

## ç‹¬å é”å®ç°

```java
public class LockAQSSolutionDemo extends AbstractQueuedSynchronizer {
    @Override
    protected boolean tryAcquire(int arg) {
        // cas åŠ é” state = 0;
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    @Override
    protected boolean tryRelease(int arg) {
        //é‡Šæ”¾é”
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }
    
    public void lock () {
        acquire(1);
    }
    
    public void unlock () {
        release(1);
    }
    
    public boolean tryLock () {
        return tryAcquire(1);
    }
    
    public boolean isLocked () {
        return isHeldExclusively();
    }

    private final static LockAQSSolutionDemo lockAQSSolutionDemo = new LockAQSSolutionDemo();
    private static int count = 0;

    public static void addCount () {
        lockAQSSolutionDemo.lock();
        try {
            count++;
        } finally {
            lockAQSSolutionDemo.unlock();
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i=0; i<5000; i++) {
                addCount();
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
            for (int i=0; i<5000; i++) {
                addCount();
            }
        }, "t2");

        t1.start();
        t2.start();
        try {
            t1.join();
            t2.join();
        } catch (Exception e) {
            // doSomething
        }
        System.out.println(count);
    }
}
```

# ReentrantLock é”çš„å®ç°

1. å…¬å¹³é”å’Œéå…¬å¹³é”ã€å¯é‡å…¥æ‰€å¦‚ä½•å®ç°ï¼›
2. è®¾è®¡æ ¸å¿ƒï¼šå¹¶å‘åœºæ™¯ä¸‹å…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œæ˜¯å¦‚ä½•è®¾è®¡çš„ï¼š
   1. çº¿ç¨‹ç«äº‰é”å¤±è´¥å…¥é˜Ÿé˜»å¡é€»è¾‘å®ç°ï¼›
   2. é‡Šæ”¾é”çš„çº¿ç¨‹å”¤é†’é˜»å¡çº¿ç¨‹å‡ºé˜Ÿç«äº‰é”çš„é€»è¾‘å®ç°ï¼›

```java
/**
 * é€šè¿‡è¿™ä¸ªä¹°ç¥¨ demo æ¥è§‚å¯Ÿç‹¬å é”çš„å®ç°
 */
public class ReentrantLockDemo {
    // é»˜è®¤éå…¬å¹³é”
    private final ReentrantLock lock = new ReentrantLock(); 
    // æ€»ç¥¨æ•°
    private static int tickets = 8;
 
    public void buyTicket() {
        // è·å–é”
        lock.lock();
        // è¿˜æœ‰ç¥¨ç»§ç»­å–
        if (tickets > 0) {
            try {
                Thread.sleep(10);
                System.out.println(Thread.currentThread().getName() + "è´­ä¹°äº†ç¬¬" + tickets-- + "å¼ ç¥¨");
            } catch (InterruptedException e) {
                // doNothing
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        ReentrantLockDemo ticketSystem = new ReentrantLockDemo();
        // åˆ›å»ºå¤šçº¿ç¨‹è´­ç¥¨
        for (int i=1; i<=10;i++) {
            Thread thread = new Thread(()->{
                // å¼€å§‹è´­ç¥¨
                ticketSystem.buyTicket();
            }, "çº¿ç¨‹" + i);
            // å¯åŠ¨çº¿ç¨‹
            thread.start();
        }
    }
}
```

debugè¯¥ç¨‹åºï¼Œè®¾ç½®debugæ¨¡å¼ä¸ºçº¿ç¨‹æ¨¡å¼ã€‚

åœ¨ lock.lock ä¸­çš„å®ç°ä¸ºï¼š

```java
static final class NonfairSync extends Sync {
  private static final long serialVersionUID = 7316153563782823691L;

  /**
         * Performs lock.  Try immediate barge, backing up to normal
         * acquire on failure.
         */
  final void lock() {
    // CAS è®¾ç½® state çš„å€¼
    if (compareAndSetState(0, 1))
      setExclusiveOwnerThread(Thread.currentThread());
    else
      acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
  }
}
```

1. é€šè¿‡ CAS è®¾ç½® state çš„å€¼ï¼›
2. è®¾ç½®å¯é‡å…¥é”çš„æ ‡å¿—ï¼›`private transient Thread exclusiveOwnerThread = çº¿ç¨‹1çš„å±æ€§`ï¼šå­˜å‚¨çš„æ˜¯çº¿ç¨‹ä¿¡æ¯ï¼›

é€šè¿‡debugå¯ä»¥çœ‹åˆ°æ˜¯çº¿ç¨‹1æŠ¢åˆ°é”äº†ï¼Œåœ¨çº¿ç¨‹1 è¿è¡Œåˆ°`if (tickets > 0)`çš„æ—¶å€™ï¼Œæ­¤æ—¶å°±ä¸è¦ç»§ç»­æ‰§è¡Œäº†ï¼Œæˆ‘ä»¬æ¢ä¸€ä¸ªçº¿ç¨‹è§‚å¯Ÿä¸€ä¸‹ã€‚æ¯”å¦‚çº¿ç¨‹10

åœ¨çº¿ç¨‹10 è¿›è¡Œ`compareAndSetState(0, 1)`çš„æ—¶å€™ï¼Œæ›´æ”¹å¤±è´¥ï¼Œæ‰§è¡Œ`acquire(1)`æ–¹æ³•ã€‚

```java
// arg = 1
public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      // Node.EXCLUSIVE = null
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
}

protected final boolean tryAcquire(int acquires) {
  return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  //getState = 1, 
  int c = getState();
  // å¯ä»¥å‘ç°çº¿ç¨‹ 10 ä»ç„¶è¦è·å–é”ï¼Œèƒ½è·å–åˆ°å°±ç»§ç»­æ‰§è¡Œ
  // è¿™å°±æ˜¯éå…¬å¹³çš„ä½“ç°
  if (c == 0) {
    if (compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  }
  //getExclusiveOwnerThread() è·å–çš„çº¿ç¨‹ä¸ºçº¿ç¨‹ 1ï¼Œå› æ­¤ä¸ç­‰
  // è¿™é‡Œå®ç°çš„é€»è¾‘ä¸»è¦æ˜¯å¯é‡å…¥é”çš„å®ç°ã€‚å½“çº¿ç¨‹1 ç›¸ç­‰çš„æ—¶å€™ï¼Œå°±ä¼šä¸º state å†æ¬¡ä¸Š acquires çš„å€¼
  // è¿™é‡Œ acquires = 1ï¼Œ c=1ï¼Œæœ€ç»ˆ state = 2
  else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
  }
  // ç›´æ¥è¿”å› false
  return false;
}
```

åœ¨è·å–é”å¤±è´¥ä¹‹åï¼Œä»ç„¶å°è¯•å†æ¬¡è·å–ä¸€æ¬¡é”ã€‚`nonfairTryAcquire`è¿™ä¸ªæ–¹æ³•è¡¨æ˜æ­¤æ—¶ä½¿ç”¨éå…¬å¹³çš„æ–¹å¼è·å–é”ã€‚ç„¶ååˆ¤æ–­å½“å‰æ‰§è¡Œçš„çº¿ç¨‹æ˜¯å¦å†æ¬¡åŠ é”äº†ï¼Œæ­¤æ—¶å°±ä¼šè¿›å…¥`else if (current == getExclusiveOwnerThread())`è¿™ä¸ªé€»è¾‘ï¼Œé”é‡å…¥çš„å®ç°ã€‚

åœ¨å¼€å§‹ä»£ç ä¸­çš„ä½“ç°å°±æ˜¯åœ¨`System.out.println(Thread.currentThread().getName() + "è´­ä¹°äº†ç¬¬" + tickets-- + "å¼ ç¥¨");`åé¢å†æ¬¡è°ƒç”¨ `buyTicket()`æ–¹æ³•ã€‚

## 1. å…¥é˜Ÿ

çº¿ç¨‹10 è·å–å°è¯•åŠ é”å¤±è´¥åï¼Œåˆ™å¼€å§‹å°†çº¿ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—`acquireQueued(addWaiter(Node.EXCLUSIVE), arg)`ã€‚

```java
private Node addWaiter(Node mode) {
  // è·å–å½“å‰çº¿ç¨‹ä¿¡æ¯
  Node node = new Node(Thread.currentThread(), mode);
  // Try the fast path of enq; backup to full enq on failure
  // æ”¾å…¥ä¸€ä¸ªåŒå‘åˆ—è¡¨ä¸­
  Node pred = tail;
  if (pred != null) {
    node.prev = pred;
    if (compareAndSetTail(pred, node)) {
      pred.next = node;
      return node;
    }
  }
  enq(node);
  return node;
}
```

ç¬¬ä¸€æ¬¡è¿›å…¥éœ€è¦åˆå§‹åŒ–åŒç«¯åˆ—è¡¨ï¼Œæ‰§è¡Œ end æ–¹æ³•ï¼š

```java
private Node enq(final Node node) {
  for (;;) {
    Node t = tail;
    if (t == null) { // Must initialize
      //å¦‚æœå°¾èŠ‚ç‚¹ä¸ºnullï¼Œå°±è¦åˆå§‹åŒ–èŠ‚ç‚¹ã€‚é€šè¿‡ CAS åˆ›å»ºä¸€ä¸ªå¤´èŠ‚ç‚¹
      if (compareAndSetHead(new Node()))
        tail = head;
    } else {
      // çº¿ç¨‹10çš„å‰é©±èŠ‚ç‚¹æŒ‡å‘tailèŠ‚ç‚¹
      node.prev = t;
      // é€šè¿‡CASå°†tailæŒ‡å‘çº¿ç¨‹10çš„èŠ‚ç‚¹
      if (compareAndSetTail(t, node)) {
        // head çš„åé©±èŠ‚ç‚¹æŒ‡å‘å°¾èŠ‚ç‚¹
        t.next = node;
        return t;
      }
    }
  }
}
```

è¿™ä¸ªåŒç«¯é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹å°±ä»£è¡¨çº¿ç¨‹1ï¼Œå› ä¸ºçº¿ç¨‹1å·²ç»å­˜å‚¨åˆ°äº†exclusiveOwnerThreadã€‚æ‰€ä»¥headèŠ‚ç‚¹æ²¡æœ‰å­˜å‚¨çº¿ç¨‹1çš„ä¿¡æ¯ã€‚ä¸ªäººè§‰å¾—è¿™ä¸ª head ç›¸å½“äºä¸€ä¸ª flagï¼Œè¡¨ç¤ºç€å‰é¢çš„äººæ­£åœ¨ä¹°ç¥¨ï¼Œåé¢çš„äººéœ€è¦ç­‰å¾…ã€‚

æœ€ç»ˆä¼šå½¢æˆè¿™æ ·ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼š

![](../photo/6.AQS-ReentrantLockå½¢æˆçš„åŒç«¯é˜Ÿé‡Œ.png)

## 2. çº¿ç¨‹æŒ‚èµ·

æ¥ç€éœ€è¦å°†çº¿ç¨‹10æŒ‚èµ·ã€‚`acquireQueued`æ–¹æ³•åˆ™å®Œæˆäº†è¿™ä¸ªåŠŸèƒ½ã€‚

```java
final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
    // è®¾ç½®ä¸­æ–­æ ‡è¯†ä¸ºä¸ºfalse
    boolean interrupted = false;
    for (;;) {
      // è·å–å‰é©±èŠ‚ç‚¹
      final Node p = node.predecessor();
      // å¦‚æœå‰é©±èŠ‚ç‚¹æ˜¯ headï¼Œå†æ¬¡å°è¯•è·å–é”ï¼Œåç»­çš„é”åˆ™ä¸ä¼šåœ¨å°è¯•è·å–äº†ã€‚
      // æ­¤æ—¶æ˜¯æ— æ³•è·å–çš„ï¼Œçº¿ç¨‹1è¿˜æ²¡æœ‰é‡Šæ”¾é”
      if (p == head && tryAcquire(arg)) {
        setHead(node);
        p.next = null; // help GC
        failed = false;
        return interrupted;
      }
      
      // ç›´æ¥è¿›å…¥è¿™ä¸ªåˆ¤æ–­é€»è¾‘ï¼Œå°†çº¿ç¨‹10 æŒ‚èµ·
      if (shouldParkAfterFailedAcquire(p, node) &&
          parkAndCheckInterrupt())
        interrupted = true;
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}
```

åœ¨å‰é©±èŠ‚ç‚¹ä¸ºå¤´èŠ‚ç‚¹æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¼šå†æ¬¡å°è¯•è·å–ä¸€æ¬¡é”ï¼Œå¤±è´¥ï¼Œåˆ™å°†å½“å‰çº¿ç¨‹æŒ‚èµ·ã€‚æ‰§è¡Œ`if (shouldParkAfterFailedAcquire(p, node) &&parkAndCheckInterrupt())`è¿™æ¡åˆ¤æ–­è¯­å¥ï¼š

`shouldParkAfterFailedAcquire(p, node)`ï¼špæ­¤æ—¶çš„å€¼æ˜¯å¤´èŠ‚ç‚¹ï¼Œnodeæ˜¯å½“å‰çº¿ç¨‹10

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  // å¤´èŠ‚ç‚¹çš„ waitStatus = -1
  int ws = pred.waitStatus;
  // Node.SIGNAL = -1ï¼Œè¡¨ç¤ºåç»§èŠ‚ç‚¹çš„çº¿ç¨‹éœ€è¦è¢«æŒ‚èµ·
  // æ‰€ä»¥æ¯ä¸ªå‰é©±èŠ‚ç‚¹çš„ waitStatus æ˜¯åé©±èŠ‚ç‚¹æŒ‚èµ·çš„æ ‡å¿—
  if (ws == Node.SIGNAL)
    /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
    // ç›´æ¥è¿”å› true
    return true;
  if (ws > 0) {
    /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
    do {
      node.prev = pred = pred.prev;
    } while (pred.waitStatus > 0);
    pred.next = node;
  } else {
    /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
}
```

æ¥ç€æ‰§è¡Œ`parkAndCheckInterrupt()`å¼€å§‹æŒ‚èµ·çº¿ç¨‹ã€‚

```java
private final boolean parkAndCheckInterrupt() {
  LockSupport.park(this);
  return Thread.interrupted();
}
```

ç„¶åä¸€ç›´debugå°†å‰©ä½™9ä¸ªçº¿ç¨‹å…¨éƒ¨æŒ‚èµ·ã€‚å«Œå¤šçš„è¯ï¼Œå¼€å§‹çš„æ—¶å€™å°‘åˆ›å»ºå‡ ä¸ªçº¿ç¨‹ğŸ˜„ã€‚

## 3. é”é‡Šæ”¾

å…¶ä½™çº¿ç¨‹æŒ‚èµ·ä¹‹åï¼Œæ¥ç€å†å›åˆ°çº¿ç¨‹1ï¼Œè®©å®ƒæ‰§è¡Œå®Œæˆä¹‹åé‡Šæ”¾é”ã€‚

```java
public void unlock() {
  sync.release(1);
}
public final boolean release(int arg) {
  // é‡Šæ”¾é”
  if (tryRelease(arg)) {
    Node h = head;
    // å”¤é†’ä¸‹ä¸€ä¸ªçº¿ç¨‹
    if (h != null && h.waitStatus != 0)
      unparkSuccessor(h);
    return true;
  }
  return false;
}
```

æ‰§è¡Œ`tryRelease(1)`é‡Šæ”¾é”

```java
protected final boolean tryRelease(int releases) {
  //æ²¡æœ‰é‡å…¥é”ï¼Œc çš„å€¼ä¸º0
  int c = getState() - releases;
  if (Thread.currentThread() != getExclusiveOwnerThread())
    throw new IllegalMonitorStateException();
  boolean free = false;
  if (c == 0) {
    free = true;
    //å°†exclusiveOwnerThread
    setExclusiveOwnerThread(null);
  }
  //é”çŠ¶æ€å€¼æ›´æ–°
  setState(c);
  return free;
}
```

## å”¤é†’ç­‰å¾…çš„çº¿ç¨‹

æ‰§è¡Œ`unparkSuccessor(Node node)`æ–¹æ³•

```
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
     // è·å–ä¹‹å‰æŒ‚èµ·æ ‡å¿—çš„å€¼
    int ws = node.waitStatus;
    if (ws < 0)
    // CAS å°† waitStatus çš„å€¼ç½®ä¸º0ï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹å°†è¦è¢«å”¤é†’ã€‚å¯ä»¥å¼€å§‹ä¹°ç¥¨äº†
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    // node.next æ˜¯çº¿ç¨‹10
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
    		// çº¿ç¨‹10 æ¢å¤è¿è¡Œï¼Œå°è¯•è·å–é”ï¼Œäºæ˜¯ä»parkAndCheckInterrupt()å¤„å¼€å§‹ç»§ç»­è¿è¡Œ
        LockSupport.unpark(s.thread);
}
```

çº¿ç¨‹10 æ¢å¤è¿è¡Œåï¼Œä»`final boolean acquireQueued(final Node node, int arg)`æ–¹æ³•ä¸­æŒ‚èµ·çº¿ç¨‹10 çš„é‚£å¤„è¯­å¥å¼€å§‹æ‰§è¡Œ`if (shouldParkAfterFailedAcquire(p, node) &&parkAndCheckInterrupt())`ï¼Œç„¶ååœ¨å¾ªç¯ä¸­å°è¯•è·å–é”

```java
for (;;) {
  // è·å–å‰é©±èŠ‚ç‚¹
  final Node p = node.predecessor();
  // æ­¤æ—¶çº¿ç¨‹10çš„å‰é©±èŠ‚ç‚¹æ˜¯å¤´èŠ‚ç‚¹ï¼Œä¸”çº¿ç¨‹1é‡Šæ”¾é”åï¼Œçº¿ç¨‹10å¯ä»¥æˆåŠŸè·å–é”
  if (p == head && tryAcquire(arg)) {
    // äºæ˜¯å¤´èŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹
    setHead(node);
    // å‰é©±èŠ‚ç‚¹çš„nextæŒ‡å‘nullï¼Œæ–­å¼€ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    p.next = null; // help GCï¼Œ
    failed = false;
    return interrupted;
  }

  // ç›´æ¥è¿›å…¥è¿™ä¸ªåˆ¤æ–­é€»è¾‘ï¼Œå°†çº¿ç¨‹10 æŒ‚èµ·
  if (shouldParkAfterFailedAcquire(p, node) &&
      parkAndCheckInterrupt())
    interrupted = true;
}
```

åé¢å‰©ä½™åœ¨é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹è¢«å”¤é†’ä»¥åŠè·å–é”ï¼Œå‡ºé˜Ÿçš„è¿‡ç¨‹ä¸æ­¤ç›¸åŒã€‚ä¸å†ä¸€ä¸€è¯´æ˜ã€‚
