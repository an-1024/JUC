# Lock 对象的使用

Java 多线程中不仅可以使用 synchronized 来保证线程的安全性，在 JDK1.5 中新增加的 ReentrantLock 类也能达到同样的效果，并且在扩展功能上更加强大。

## ReentrantLock 类

下面来介绍一下 ReentrantLock 的使用方式。

创建方法类:

```java
public class MyReentRantLockService {
    private Lock lock = new ReentrantLock();
    
    public void reentrantLockService(){
        // 加锁
        lock.lock();
        for (int i=0; i<5; i++){
            System.out.println("ThreadName = " + Thread.currentThread().getName() + (" " + (i + 1)));
        }
        // 释放锁
        lock.unlock();
    }
}
```
方法执行前加锁，执行完成释放锁。

接着创建线程类：

```java
public class MyReentRantLockThread implements Runnable{
    
    private MyReentRantLockService myReentRantLockService;

    public MyReentRantLockThread(MyReentRantLockService myReentRantLockService) {
        this.myReentRantLockService = myReentRantLockService;
    }

    public void run() {
        myReentRantLockService.reentrantLockService();
    }
}
```
创建测试类 demo

```java
public class MyReentRantLockThreadTest {
    public static void main(String[] args) {
        MyReentRantLockService myReentRantLockService = new MyReentRantLockService();
        
        for (int i=0; i<2; i++){
            MyReentRantLockThread myReentRantLockThread = new MyReentRantLockThread(myReentRantLockService);
            Thread t1 = new Thread(myReentRantLockThread);
            t1.setName("Thread=" + i);
            t1.start();
        }
    }
}
```

运行结果：

```text
ThreadName = Thread=0 1
ThreadName = Thread=0 2
ThreadName = Thread=0 3
ThreadName = Thread=0 4
ThreadName = Thread=0 5
ThreadName = Thread=1 1
ThreadName = Thread=1 2
ThreadName = Thread=1 3
ThreadName = Thread=1 4
ThreadName = Thread=1 5
```

根据结果可以看到，只有当前线程执行完成释放锁之后，其他线程才可以执行。

## await() 方法的错误用法与更正

关键字 synchronized 与 wait()、notify()/notifyAll() 方法相结合可以实现 wait/notify 模式。 ReentrantLock 类也可以实现同样的功能。但是
需要借助 Condition 对象。Condition 类是 JDK 5 的技术，具有更多的灵活性

Condition 对象的作用是控制并处理线程的状态，可以使线程呈 wait() 状态，也可以让线程继续运行。

创建方法类:

```java
public class MyReentrantLockConditionService {
    
    private Condition condition = new ReentrantLock().newCondition();
    
    
    public void waitCondition(){
        try {
            condition.await();
        } catch (InterruptedException e) {
            // doNothing
        }
    }
    
}
```

await() 方法的作用是使当前线程连接到通知或被中断之前一直处于等待 wait 状态，和 wait() 方法的作用一样

创建线程类：

```java
public class MyReentrantLockConditionServiceThread implements Runnable{
    
    private MyReentrantLockConditionService conditionService;

    public MyReentrantLockConditionServiceThread(MyReentrantLockConditionService conditionService) {
        this.conditionService = conditionService;
    }

    @Override
    public void run() {
        conditionService.waitCondition();
    }
}
```

测试类：

```java
public class MyReentrantLockConditionServiceThreadTest {
    public static void main(String[] args) {
        MyReentrantLockConditionService conditionService = new MyReentrantLockConditionService();
        
        Thread t1 = new Thread(new MyReentrantLockConditionServiceThread(conditionService));
        t1.start();
    }
}
```

执行方法, 会发现抛异常了。

```text
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease(AbstractQueuedSynchronizer.java:1723)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2036)
	at com.anzhi.reentrantlockuse.MyReentrantLockConditionService.waitCondition(MyReentrantLockConditionService.java:13)
	at com.anzhi.reentrantlockuse.MyReentrantLockConditionServiceThread.run(MyReentrantLockConditionServiceThread.java:13)
	at java.lang.Thread.run(Thread.java:748)
```

报错的异常信息是监视器出错，这是因为在执行 condition.await() 方法调用之前必须先获得对象的锁，即lock.lock()。修改 MyReentrantLockConditionService
类：

```java
public class MyReentrantLockConditionService {
    
    private Lock lock = new ReentrantLock();
    
    private Condition condition = lock.newCondition();
    
    
    public void waitCondition(){
        try {
            lock.lock();
            System.out.println("上锁等待解锁");
            System.out.println(" 执行 await 方法, 使线程进入 wait 状态");
            condition.await();
            System.out.println();
        } catch (InterruptedException e) {
            // doNothing
        }finally {
            lock.unlock();
            System.out.println("锁释放了");
        }
    }
    
}
```

运行程序结果：

```text
上锁等待解锁
 执行 await 方法, 使线程t0进入 wait 状态
上锁等待解锁
 执行 await 方法, 使线程t1进入 wait 状态
上锁等待解锁
 执行 await 方法, 使线程t2进入 wait 状态
```

根据结果可以发现调用了 Condition 对象的 await() 方法将当前执行任务的线程转换成 wait 状态并释放了锁。

## 使用 await 和 signal 实现 wait/notify 机制

创建方法: 

```java
public class MyReentrantLockAwaitSignalService {
    private Lock lock = new ReentrantLock();
    
    public Condition condition = lock.newCondition();
    
    public void awaitMethod(){
        try{
            lock.lock();
            System.out.println("  await 时间为" + System.currentTimeMillis());
            condition.await();
        }catch (Exception e){
            // doNothing
        }
    }
    
    
    public void signalMethod(){
        try{
            lock.lock();
            System.out.println(" signal 时间为" + System.currentTimeMillis());
            condition.signal();
        }catch (Exception e){
            
        }
    }
}
```

实现 await 方法与 signal 方法

创建相应的线程

```java
public class MyReentrantLockAwaitSignalServiceThread implements Runnable{
    
    private MyReentrantLockAwaitSignalService awaitSignalService = new MyReentrantLockAwaitSignalService();

    public MyReentrantLockAwaitSignalServiceThread(MyReentrantLockAwaitSignalService awaitSignalService) {
        this.awaitSignalService = awaitSignalService;
    }

    @Override
    public void run() {
        awaitSignalService.awaitMethod();
    }
}
```
创建测试类

```java
public class MyReentrantLockAwaitSignalServiceThreadTest {
    public static void main(String[] args) {

        MyReentrantLockAwaitSignalService awaitSignalService = new MyReentrantLockAwaitSignalService();

        Thread thread = new Thread(new MyReentrantLockAwaitSignalServiceThread(awaitSignalService));
        thread.setName("t1");
        thread.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }
        
        awaitSignalService.signalMethod();
    }
}
```

运行程序结果：

```text
  await 时间为1658055080901
 signal 时间为1658055083902
```

可以看到线程 thread 先调用了 Condition.await  使线程处于暂停状态，接着调用 signal 通知线程继续执行。

# 通知部分线程

创建方法: 

```java
public class MyReentrantLockAwaitSignalMoreConditionService {
    private Lock lock = new ReentrantLock();
    
    public Condition conditionA = lock.newCondition();
    public Condition conditionB = lock.newCondition();
    
    public void awaitMethodA(){
        lock.lock();
        System.out.println("begin awaitMethodA 时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        try {
            conditionA.await();
            System.out.println("  endi awaitA时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        } catch (InterruptedException e) {
            // doNothing
        }finally {
            lock.unlock();
        }
    }
    
    public void awaitMethodB(){
        lock.lock();
        System.out.println("begin awaitMethodB 时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        try {
            conditionB.await();
            System.out.println("  endi awaitB时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        } catch (InterruptedException e) {
            // doNothing
        }finally {
            lock.unlock();
        }
    }
    
    public void signalAll_A(){
        lock.lock();
        System.out.println("     signalAll_A 时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        try {
            conditionA.signalAll();
        } catch (Exception e) {
            // doNothing
        }finally {
            lock.unlock();
        }
    }

    public void signalAll_B(){
        lock.lock();
        System.out.println("     signalAll_B 时间为" + System.currentTimeMillis() + " ThreadName = " + Thread.currentThread().getName());
        try {
            conditionB.signalAll();
        } catch (Exception e) {
            // doNothing
        }finally {
            lock.unlock();
        }
    }
    
}
```

创建 A、B 线程

```java
public class MyReentrantLockAwaitSignalMoreConditionServiceThreadA implements Runnable{
    
    private MyReentrantLockAwaitSignalMoreConditionService awaitSignalMoreConditionService = new MyReentrantLockAwaitSignalMoreConditionService();

    public MyReentrantLockAwaitSignalMoreConditionServiceThreadA(MyReentrantLockAwaitSignalMoreConditionService awaitSignalMoreConditionService) {
        this.awaitSignalMoreConditionService = awaitSignalMoreConditionService;
    }

    @Override
    public void run() {
        awaitSignalMoreConditionService.awaitMethodA();
    }
}

public class MyReentrantLockAwaitSignalMoreConditionServiceThreadB implements Runnable{
    private MyReentrantLockAwaitSignalMoreConditionService awaitSignalMoreConditionService = new MyReentrantLockAwaitSignalMoreConditionService();

    public MyReentrantLockAwaitSignalMoreConditionServiceThreadB(MyReentrantLockAwaitSignalMoreConditionService awaitSignalMoreConditionService) {
        this.awaitSignalMoreConditionService = awaitSignalMoreConditionService;
    }

    @Override
    public void run() {
        awaitSignalMoreConditionService.awaitMethodB();
    }
}
```

创建测试类

```java
public class MyReentrantLockAwaitSignalMoreConditionServiceThreadTest {
    public static void main(String[] args) {
        MyReentrantLockAwaitSignalMoreConditionService awaitSignalMoreConditionService = new MyReentrantLockAwaitSignalMoreConditionService();
        
        MyReentrantLockAwaitSignalMoreConditionServiceThreadA serviceThreadA = new MyReentrantLockAwaitSignalMoreConditionServiceThreadA(awaitSignalMoreConditionService);
        MyReentrantLockAwaitSignalMoreConditionServiceThreadB serviceThreadB = new MyReentrantLockAwaitSignalMoreConditionServiceThreadB(awaitSignalMoreConditionService);
        
        Thread threadA = new Thread(serviceThreadA);
        threadA.setName("threadA");
        
        Thread threadB = new Thread(serviceThreadB);
        threadB.setName("threadB");
        
        threadA.start();
        threadB.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }
        
        awaitSignalMoreConditionService.signalAll_A();
    }
}
```

运行程序结果：

```text
begin awaitMethodA 时间为1658062070092 ThreadName = threadA
begin awaitMethodB 时间为1658062070093 ThreadName = threadB
     signalAll_A 时间为1658062073093 ThreadName = main
  endi awaitA时间为1658062073093 ThreadName = threadA
```

使用 Condition 对象可以唤醒指定种类的线程，这是控制部分线程行为的方便方式。

# 生产者/消费者模式多对多交替输出

创建方法类： 

```java
public class MyReentrantLockConditionMethod {

    // 创建锁
    Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    private int hasValue = 0;

    public void set(){
        try {
            lock.lock();
            while (hasValue == 1) {
                System.out.println("  有可能★★★连续");
                condition.await();
            }
            System.out.println("打印★");
            hasValue = 1;
            condition.signalAll();
        }catch (Exception e){
            // doNothing
        }finally {
            lock.unlock();
        }
    }


    public void get(){
        try{
            lock.lock();
            while(hasValue == 0){
                System.out.println(" 有可能连续☆☆☆");
                condition.await();
            }
            System.out.println("打印☆");
            hasValue = 0;
            condition.signalAll();
        }catch (Exception e){
            // doNothing
        }finally {
            lock.unlock();
        }
    }
}
```

创建生产消费者类：

```java
public class MyReentrantLockConditionConsumerThread implements Runnable{

    private MyReentrantLockConditionMethod conditionMethod;

    public MyReentrantLockConditionConsumerThread(MyReentrantLockConditionMethod conditionMethod) {
        this.conditionMethod = conditionMethod;
    }

    @Override
    public void run() {
        for(int i=0; i<Integer.MAX_VALUE; i++){
            conditionMethod.get();
        }
    }
}

public class MyReentrantLockConditionProducerThread implements Runnable{

    private MyReentrantLockConditionMethod conditionMethod;

    public MyReentrantLockConditionProducerThread(MyReentrantLockConditionMethod conditionMethod) {
        this.conditionMethod = conditionMethod;
    }

    @Override
    public void run() {
        for(int i=0; i<Integer.MAX_VALUE; i++){
            conditionMethod.set();
        }
    }
}
```

创建测试类：

```java
public class MyReentrantLockConditionMethodDemoTest {
    public static void main(String[] args) {
        MyReentrantLockConditionMethod conditionMethod = new MyReentrantLockConditionMethod();

        MyReentrantLockConditionConsumerThread[] consumerThreadArray = new MyReentrantLockConditionConsumerThread[10];
        MyReentrantLockConditionProducerThread[] producerThreadArray = new MyReentrantLockConditionProducerThread[10];

        for (int i=0; i<10; i++){
            producerThreadArray[i] = new MyReentrantLockConditionProducerThread(conditionMethod);
            consumerThreadArray[i] = new MyReentrantLockConditionConsumerThread(conditionMethod);

            Thread t1 = new Thread(producerThreadArray[i]);
            Thread t2 = new Thread(consumerThreadArray[i]);

            t1.start();
            t2.start();
        }

    }
}
```

输出结果：

```text
打印★
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
打印☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
打印★
  有可能★★★连续
打印☆
 有可能连续☆☆☆
打印★
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
  有可能★★★连续
打印☆
 有可能连续☆☆☆
打印★
  有可能★★★连续
打印☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
 有可能连续☆☆☆
打印★
  有可能★★★连续
打印☆
 有可能连续☆☆☆
打印★
  有可能★★★连续
打印☆
 有可能连续☆☆☆
 有可能连续☆☆☆
打印★
.....

```

# 公平锁与非公平锁

Lock 锁分为 “公平锁” 和 “非公平锁”。 公平锁表示线程获取锁的顺序是按照加锁的顺序来分配的，即先来先得的 FIFO 先进先出的顺序。而非公平锁就是一种
获取锁的抢占机制，是随机获取锁的，这种机制可能造成某些线程一直拿不到锁。

## 公平锁测试

创建 方法类

```java
public class LockFairMethod {
    private ReentrantLock lock;

    public LockFairMethod(boolean isFair) {
        lock = new ReentrantLock(isFair);
    }

    public void lockMethodService(){
        try{
            lock.lock();
            System.out.println("ThreadName= " + Thread.currentThread().getName() + " 获得锁定");
        }finally {
            lock.unlock();
        }
    }
}
```

创建测试类

```java
public class LockRunFairDemoTest {
    public static void main(String[] args) {
        final LockFairMethod lockFairMethod = new LockFairMethod(true);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("★线程 " + Thread.currentThread().getName() + "运行了 ");
                lockFairMethod.lockMethodService();
            }
        };

        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++){
            threadArray[i] = new Thread(runnable);
        }

        for(int i=0; i<10; i++){
            threadArray[i].start();
        }
    }
}
```

运行结果：

```text
★线程 Thread-1运行了 
★线程 Thread-4运行了 
★线程 Thread-3运行了 
★线程 Thread-2运行了 
★线程 Thread-0运行了 
★线程 Thread-6运行了 
ThreadName= Thread-1 获得锁定
★线程 Thread-8运行了 
★线程 Thread-5运行了 
★线程 Thread-9运行了 
★线程 Thread-7运行了 
ThreadName= Thread-4 获得锁定
ThreadName= Thread-3 获得锁定
ThreadName= Thread-2 获得锁定
ThreadName= Thread-0 获得锁定
ThreadName= Thread-6 获得锁定
ThreadName= Thread-8 获得锁定
ThreadName= Thread-5 获得锁定
ThreadName= Thread-9 获得锁定
ThreadName= Thread-7 获得锁定
```

根据结果可以看到是按照线程运行的先后活得 lock 锁。

## 非公平锁测试

将


输出结果：

```text
★线程 Thread-0运行了 
★线程 Thread-7运行了 
★线程 Thread-5运行了 
★线程 Thread-6运行了 
★线程 Thread-4运行了 
★线程 Thread-3运行了 
★线程 Thread-2运行了 
★线程 Thread-1运行了 
★线程 Thread-9运行了 
ThreadName= Thread-0 获得锁定
★线程 Thread-8运行了 
ThreadName= Thread-8 获得锁定
ThreadName= Thread-7 获得锁定
ThreadName= Thread-5 获得锁定
ThreadName= Thread-6 获得锁定
ThreadName= Thread-4 获得锁定
ThreadName= Thread-3 获得锁定
ThreadName= Thread-2 获得锁定
ThreadName= Thread-1 获得锁定
ThreadName= Thread-9 获得锁定
```

根据结果可以看出获得锁的顺序并没有按照线程的启动顺序来获得锁定。

## getHoldCount 方法的使用

该方法的作用是查询 "当前线程" 保持锁定的个数，即调用 lock() 方法的次数。

创建方法类:

````java
public class GetholdCountMethodDemo {
    private ReentrantLock lock = new ReentrantLock(true);

    public void lockMethod1(){
        System.out.println("A " + lock.getHoldCount());
        lock.lock();;
        System.out.println("B " + lock.getHoldCount());
        lockMethod2();
        System.out.println("F " + lock.getHoldCount());
        lock.unlock();
        System.out.println("G " + lock.getHoldCount());
    }

    public void lockMethod2(){
        System.out.println("C " + lock.getHoldCount());
        lock.lock();;
        System.out.println("D " + lock.getHoldCount());
        lock.unlock();
        System.out.println("E " + lock.getHoldCount());

    }
}
````

创建测试类

```java
public class GetholdCountMethodDemoTest {
    public static void main(String[] args) {
        GetholdCountMethodDemo holdCountMethodDemo = new GetholdCountMethodDemo();
        holdCountMethodDemo.lockMethod1();
    }
}
```
运行结果如下:

```text
A 0
B 1
C 1
D 2
E 1
F 1
G 0
```
执行 lock() 方法进行锁重入导致 count 计数加 1 的效果，执行 unlock() 方法会使 count 呈减 1 的效果。

## getQueueLength 方法的使用

该方法的作用是返回正在等待获取此锁的线程估计数。

创建方法类：

```java
public class GetQueueLengthMethodDemo {
    private ReentrantLock lock = new ReentrantLock(true);

    public void queueLengthMethodDemo(){
        try{
            lock.lock();
            System.out.println("ThreadName= " + Thread.currentThread().getName() + "进入方法");
            Thread.sleep(Integer.MAX_VALUE);
        }catch (Exception e){
            // doNothing
        }finally {
            lock.unlock();
        }
    }

    public ReentrantLock getLock() {
        return lock;
    }
}
```
创建测试类：

```java
public class GetQueueLengthMethodDemoTest {
    public static void main(String[] args) {
        GetQueueLengthMethodDemo queueLengthMethodDemo = new GetQueueLengthMethodDemo();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                queueLengthMethodDemo.queueLengthMethodDemo();
            }
        };

        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++){
            threadArray[i] = new Thread(runnable);
        }

        for(int i=0; i<10; i++){
            threadArray[i].start();
        }

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            // doNothing
        }

        System.out.println("有线程数： " + queueLengthMethodDemo.getLock().getQueueLength() + "在等待获取锁");
    }
}
```

输出结果如下：

```text
ThreadName= Thread-0进入方法
有线程数： 9在等待获取锁
```

## getWaitQueueLength 方法的使用

该方法的作用是返回等待与此锁相关给定条件 Condition 的线程估计数。
