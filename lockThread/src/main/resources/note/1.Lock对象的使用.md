# Lock 对象的使用

Java 多线程中不仅可以使用 synchronized 来保证线程的安全性，在 JDK1.5 中新增加的 ReentrantLock 类也能达到同样的效果，并且在扩展功能上更加强大。

## ReentrantLock 类

下面来介绍一下 ReentrantLock 的使用方式。

创建方法类:

```java
public class MyReentRantLockService {
    private Lock lock = new ReentrantLock();
    
    public void reentrantLockService(){
        // 加锁
        lock.lock();
        for (int i=0; i<5; i++){
            System.out.println("ThreadName = " + Thread.currentThread().getName() + (" " + (i + 1)));
        }
        // 释放锁
        lock.unlock();
    }
}
```
方法执行前加锁，执行完成释放锁。

接着创建线程类：

```java
public class MyReentRantLockThread implements Runnable{
    
    private MyReentRantLockService myReentRantLockService;

    public MyReentRantLockThread(MyReentRantLockService myReentRantLockService) {
        this.myReentRantLockService = myReentRantLockService;
    }

    public void run() {
        myReentRantLockService.reentrantLockService();
    }
}
```
创建测试类 demo

```java
public class MyReentRantLockThreadTest {
    public static void main(String[] args) {
        MyReentRantLockService myReentRantLockService = new MyReentRantLockService();
        
        for (int i=0; i<2; i++){
            MyReentRantLockThread myReentRantLockThread = new MyReentRantLockThread(myReentRantLockService);
            Thread t1 = new Thread(myReentRantLockThread);
            t1.setName("Thread=" + i);
            t1.start();
        }
    }
}
```

运行结果：

```text
ThreadName = Thread=0 1
ThreadName = Thread=0 2
ThreadName = Thread=0 3
ThreadName = Thread=0 4
ThreadName = Thread=0 5
ThreadName = Thread=1 1
ThreadName = Thread=1 2
ThreadName = Thread=1 3
ThreadName = Thread=1 4
ThreadName = Thread=1 5
```

根据结果可以看到，只有当前线程执行完成释放锁之后，其他线程才可以执行。

# await() 方法的错误用法与更正

关键字 synchronized 与 wait()、notify()/notifyAll() 方法相结合可以实现 wait/notify 模式。 ReentrantLock 类也可以实现同样的功能。但是
需要借助 Condition 对象。Condition 类是 JDK 5 的技术，具有更多的灵活性

Condition 对象的作用是控制并处理线程的状态，可以是线程呈 wait() 状态，也可以让线程继续运行。

创建方法类:

```java
public class MyReentrantLockConditionService {
    
    private Condition condition = new ReentrantLock().newCondition();
    
    
    public void waitCondition(){
        try {
            condition.await();
        } catch (InterruptedException e) {
            // doNothing
        }
    }
    
}
```

await() 方法的作用是使当前线程连接到通知或被中断之前一直处于等待 wait 状态，和 wait() 方法的作用一样

创建线程类：

```java
public class MyReentrantLockConditionServiceThread implements Runnable{
    
    private MyReentrantLockConditionService conditionService;

    public MyReentrantLockConditionServiceThread(MyReentrantLockConditionService conditionService) {
        this.conditionService = conditionService;
    }

    @Override
    public void run() {
        conditionService.waitCondition();
    }
}
```

测试类：

```java
public class MyReentrantLockConditionServiceThreadTest {
    public static void main(String[] args) {
        MyReentrantLockConditionService conditionService = new MyReentrantLockConditionService();
        
        Thread t1 = new Thread(new MyReentrantLockConditionServiceThread(conditionService));
        t1.start();
    }
}
```

执行方法, 会发现抛异常了。

```text
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease(AbstractQueuedSynchronizer.java:1723)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2036)
	at com.anzhi.reentrantlockuse.MyReentrantLockConditionService.waitCondition(MyReentrantLockConditionService.java:13)
	at com.anzhi.reentrantlockuse.MyReentrantLockConditionServiceThread.run(MyReentrantLockConditionServiceThread.java:13)
	at java.lang.Thread.run(Thread.java:748)
```

报错的异常信息是监视器出错，这是因为在执行 condition.await() 方法调用之前必须先获得对象的锁，即lock.lock()。修改 MyReentrantLockConditionService
类：

```java
public class MyReentrantLockConditionService {
    
    private Lock lock = new ReentrantLock();
    
    private Condition condition = lock.newCondition();
    
    
    public void waitCondition(){
        try {
            lock.lock();
            System.out.println("上锁等待解锁");
            System.out.println(" 执行 await 方法, 使线程进入 wait 状态");
            condition.await();
            System.out.println();
        } catch (InterruptedException e) {
            // doNothing
        }finally {
            lock.unlock();
            System.out.println("锁释放了");
        }
    }
    
}
```

运行程序结果：

```text
上锁等待解锁
 执行 await 方法, 使线程t0进入 wait 状态
上锁等待解锁
 执行 await 方法, 使线程t1进入 wait 状态
上锁等待解锁
 执行 await 方法, 使线程t2进入 wait 状态
```

根据结果可以发现调用了 Condition 对象的 await() 方法将当前执行任务的线程转换成 wait 状态并释放了锁。

# 使用 await 和 signal 实现 wait/notify 机制

创建方法: 

```java
public class MyReentrantLockAwaitSignalService {
    private Lock lock = new ReentrantLock();
    
    public Condition condition = lock.newCondition();
    
    public void awaitMethod(){
        try{
            lock.lock();
            System.out.println("  await 时间为" + System.currentTimeMillis());
            condition.await();
        }catch (Exception e){
            // doNothing
        }
    }
    
    
    public void signalMethod(){
        try{
            lock.lock();
            System.out.println(" signal 时间为" + System.currentTimeMillis());
            condition.signal();
        }catch (Exception e){
            
        }
    }
}
```

实现 await 方法与 signal 方法

创建相应的线程

```java
public class MyReentrantLockAwaitSignalServiceThread implements Runnable{
    
    private MyReentrantLockAwaitSignalService awaitSignalService = new MyReentrantLockAwaitSignalService();

    public MyReentrantLockAwaitSignalServiceThread(MyReentrantLockAwaitSignalService awaitSignalService) {
        this.awaitSignalService = awaitSignalService;
    }

    @Override
    public void run() {
        awaitSignalService.awaitMethod();
    }
}
```
创建测试类

```java
public class MyReentrantLockAwaitSignalServiceThreadTest {
    public static void main(String[] args) {

        MyReentrantLockAwaitSignalService awaitSignalService = new MyReentrantLockAwaitSignalService();

        Thread thread = new Thread(new MyReentrantLockAwaitSignalServiceThread(awaitSignalService));
        thread.setName("t1");
        thread.start();

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // doNothing
        }
        
        awaitSignalService.signalMethod();
    }
}
```

运行程序结果：

```text
  await 时间为1658055080901
 signal 时间为1658055083902
```

可以看到线程 thread 先调用了 Condition.await  使线程处于暂停状态，接着调用 signal 通知线程



