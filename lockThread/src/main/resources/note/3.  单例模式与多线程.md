# 立即加载/饿汉模式

立即加载是指使用类的时候已经将对象创建完毕，常见的实现办法是直接用 new 实例化。从场景分析上看，在未使用对象之前就已经将对象创建，如果没有使用也就白创建了。
所以这种方式也称为 "饿汉模式"。

创建单例类：

```java
public class HungryManModeDemo {
    private static HungryManModeDemo singleObject = new HungryManModeDemo();

    public HungryManModeDemo() {
    }

    public static HungryManModeDemo getInstance(){
        return singleObject;
    }
}
```

创建线程类:

```java
public class HungryManModeDemoThread implements Runnable{
    @Override
    public void run() {
        System.out.println(HungryManModeDemo.getInstance().hashCode());
    }
}
```
创建测试类:

```java
public class HungryManModeDemoThreadTest {
    public static void main(String[] args) {
        HungryManModeDemoThread hungryManModeDemo1 = new HungryManModeDemoThread();
        Thread t1 = new Thread(hungryManModeDemo1);

        HungryManModeDemoThread hungryManModeDemo2 = new HungryManModeDemoThread();
        Thread t2 = new Thread(hungryManModeDemo2);

        HungryManModeDemoThread hungryManModeDemo3 = new HungryManModeDemoThread();
        Thread t3 = new Thread(hungryManModeDemo3);

        t1.start();
        t2.start();
        t3.start();
    }
}
```
输出结果：

```text
1219789063
1219789063
1219789063
```

可以看到对象都是一个。但是这样的单例模式线程不安全。(下面会介绍如何解决这个问题)

# 延迟加载/懒汉模式

延迟加载是指调用 get() 方法时实例才被工厂创建。这种方式也被称之为 "懒汉模式"

创建类:

```java
public class LazyModeDemo {

    private static LazyModeDemo lazyModeDemo;

    public LazyModeDemo() {
    }

    public static LazyModeDemo getInstance(){
        if (lazyModeDemo != null){
        }else {
            lazyModeDemo = new LazyModeDemo();
        }
        return lazyModeDemo;
    }
}
```
创建线程类:

```java
public class LazyModeDemoThread implements Runnable{
    @Override
    public void run() {
        System.out.println(LazyModeDemo.getInstance().hashCode());
    }
}
```
创建测试类:

```java
public class LazyModeDemoThreadTest {
    public static void main(String[] args) {
        LazyModeDemoThread lazyModeDemo1 = new LazyModeDemoThread();
        Thread t1 = new Thread(lazyModeDemo1);

        LazyModeDemoThread lazyModeDemo2= new LazyModeDemoThread();
        Thread t2 = new Thread(lazyModeDemo2);

        t1.start();
        t2.start();
    }
}
```

运行程序结果:

```text
438662658
438662658
```

懒汉模式同样存在线程安全。在 if (Object != null) 判断存在线程安全。如何解决？第一想到的是加锁，实例化方法使用 synchronized 修饰，使用此锁虽然能保证
线程安全，但是会导致运行效率非常低。进一步优化修饰代码块，不对整个方法进行加锁。代码如下:

```java
public class LazyModSynchronizedDemo {

    private static LazyModSynchronizedDemo lazyModeDemo;

    public LazyModSynchronizedDemo() {
    }

    public static LazyModSynchronizedDemo getInstance(){
        if (lazyModeDemo != null){
        }else {
            // 模拟在创建对象之前做一些准备性的工作
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                // doNothing
            }
            synchronized(LazyModeDemo.class) {
                lazyModeDemo = new LazyModSynchronizedDemo();
            }
        }
        return lazyModeDemo;
    }
}
```
仔细看会发现这段代码仍然是线程不安全的。多线程下，else 判断中仍然无法解决得到同一个实例对象的结果。最终解决就需要提到著名的 DCL 机制(Dubbo-Check)

# DCL 机制

代码如下:

```java
public class DCLDemo {
    private static volatile DCLDemo dclDemo;
    
    public static DCLDemo getInstance(){
        if(dclDemo != null){
        }else{
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                // doNothing
            }
            synchronized (DCLDemo.class){
                if (dclDemo == null){
                    dclDemo = new DCLDemo();
                }
            }
        }
        return dclDemo;
    }
}
```
在 synchronized 同步代码快中再次添加判断，同时使用 volatile 修饰变量保证可见性，并禁止代码重排序。这是因为 dclDemo = new DCLDemo(); 在
代码内分为 3 个步骤:

1. mermory = allocate(); // 分配对象的内存空间;
2. ctorInstance(memory); // 初始化对象
3. dclDemo = memory;     // 设置 instance 指向刚分配的内存地址

编译器很可能将这几个命令重排

1. mermory = allocate(); // 分配对象的内存空间;
2. dclDemo = memory;     // 设置 instance 指向刚分配的内存地址
3. ctorInstance(memory); // 初始化对象

上面重排指令的结果会导致 dclDemo 构造方法还没有执行，但是 dclDemo 对象具有了内存地址，值便不是 null 了，当访问 delDemo 对象中的的实量时还是
数据类型的默认值。

## 验证 volatile 的必要性

创建使用类:

```java
public class DCLReorderingDemo {
    public int i_am_has_state = 0;

    private static DCLReorderingDemo dclReorderingDemo;

    private DCLReorderingDemo () {
        i_am_has_state = new Random().nextInt(200) + 1;
    }

    public static DCLReorderingDemo getInstance() {
        if (dclReorderingDemo == null) {
            synchronized (DCLReorderingDemo.class){
                if (dclReorderingDemo == null){
                    dclReorderingDemo = new DCLReorderingDemo();
                }
            }
        }
        return dclReorderingDemo;
    }

    public static void reset() {
        dclReorderingDemo = null;
    }
}
```
创建测试类

```java
public class DCLReorderingDemoTest {
    public static void main(String[] args) {
        for(;;){
            CountDownLatch latch = new CountDownLatch(1);
            CountDownLatch end = new CountDownLatch(100);
            for (int i=0; i<100; i++) {
                Thread t1 =  new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            latch.await();
                            DCLReorderingDemo one = DCLReorderingDemo.getInstance();
                            if (one.i_am_has_state == 0) {
                                System.out.println("one.i_am_has_state == 0 进程结束");
                                System.exit(0);
                            }
                            end.countDown();
                        } catch (InterruptedException e) {
                            // doNothing
                        }
                    }
                });

                t1.start();
            }
            latch.countDown();
            try {
                end.await();
            } catch (InterruptedException e) {
                // doNothing
            }
            DCLReorderingDemo.reset();
        }
    }
}
```

程序最终输出结果:

```text
one.i_am_has_state == 0 进程结束
one.i_am_has_state == 0 进程结束
```
说明在 DCLReorderingDemo one = DCLReorderingDemo.getInstance(); 发生了指令重排序而导致线程退出。

# 使用静态内置类实现单例模式

除了 DCL 还有其他方式可以实现单例模式。代码如下:

```java
public class StaticInnerClassDemo {
    private static class StaticInnerClass{
        private static StaticInnerClassDemo innerClassDemo = new StaticInnerClassDemo();
    }

    private StaticInnerClassDemo (){}

    public static StaticInnerClassDemo getInstance(){
        return StaticInnerClass.innerClassDemo;
    }
}
```

创建线程类:

```java
public class StaticInnerClassDemoThread implements Runnable{

    @Override
    public void run() {
        System.out.println(StaticInnerClassDemo.getInstance().hashCode());
    }
}
```
创建测试类:

```java
public class StaticInnerClassDemoThreadTest {
    public static void main(String[] args) {
        for (int i=0; i<100; i++){
            StaticInnerClassDemoThread innerClassDemoThread = new StaticInnerClassDemoThread();
            Thread t1 = new Thread(innerClassDemoThread);
            t1.start();
        }
    }
}
```
输出结果:

```text
354056774
354056774
354056774
354056774
354056774
354056774
354056774
354056774
……
```

可以看到获得的都是同一个对象。

# 使用枚举类