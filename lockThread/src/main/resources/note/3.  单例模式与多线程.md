# 立即加载/饿汉模式

立即加载是指使用类的时候已经将对象创建完毕，常见的实现办法是直接用 new 实例化。从场景分析上看，在未使用对象之前就已经将对象创建，如果没有使用也就白创建了。
所以这种方式也称为 "饿汉模式"。

创建单例类：

```java
public class HungryManModeDemo {
    private static HungryManModeDemo singleObject = new HungryManModeDemo();

    public HungryManModeDemo() {
    }

    public static HungryManModeDemo getInstance(){
        return singleObject;
    }
}
```

创建线程类:

```java
public class HungryManModeDemoThread implements Runnable{
    @Override
    public void run() {
        System.out.println(HungryManModeDemo.getInstance().hashCode());
    }
}
```
创建测试类:

```java
public class HungryManModeDemoThreadTest {
    public static void main(String[] args) {
        HungryManModeDemoThread hungryManModeDemo1 = new HungryManModeDemoThread();
        Thread t1 = new Thread(hungryManModeDemo1);

        HungryManModeDemoThread hungryManModeDemo2 = new HungryManModeDemoThread();
        Thread t2 = new Thread(hungryManModeDemo2);

        HungryManModeDemoThread hungryManModeDemo3 = new HungryManModeDemoThread();
        Thread t3 = new Thread(hungryManModeDemo3);

        t1.start();
        t2.start();
        t3.start();
    }
}
```
输出结果：

```text
1219789063
1219789063
1219789063
```

可以看到对象都是一个。但是这样的单例模式线程不安全。(下面会介绍如何解决这个问题)

# 延迟加载/懒汉模式

延迟加载是指调用 get() 方法时实例才被工厂创建。这种方式也被称之为 "懒汉模式"

创建类:

```java
public class LazyModeDemo {

    private static LazyModeDemo lazyModeDemo;

    public LazyModeDemo() {
    }

    public static LazyModeDemo getInstance(){
        if (lazyModeDemo != null){
        }else {
            lazyModeDemo = new LazyModeDemo();
        }
        return lazyModeDemo;
    }
}
```
创建线程类:

```java
public class LazyModeDemoThread implements Runnable{
    @Override
    public void run() {
        System.out.println(LazyModeDemo.getInstance().hashCode());
    }
}
```
创建测试类:

```java
public class LazyModeDemoThreadTest {
    public static void main(String[] args) {
        LazyModeDemoThread lazyModeDemo1 = new LazyModeDemoThread();
        Thread t1 = new Thread(lazyModeDemo1);

        LazyModeDemoThread lazyModeDemo2= new LazyModeDemoThread();
        Thread t2 = new Thread(lazyModeDemo2);

        t1.start();
        t2.start();
    }
}
```

运行程序结果:

```text
438662658
438662658
```

懒汉模式同样存在线程安全。在 if (Object != null) 判断存在线程安全。如何解决？第一想到的是加锁，实例化方法使用 synchronized 修饰，使用此锁虽然能保证
线程安全，但是会导致运行效率非常低。进一步优化修饰代码块，不对整个方法进行加锁。代码如下:

```java
public class LazyModSynchronizedDemo {

    private static LazyModSynchronizedDemo lazyModeDemo;

    public LazyModSynchronizedDemo() {
    }

    public static LazyModSynchronizedDemo getInstance(){
        if (lazyModeDemo != null){
        }else {
            // 模拟在创建对象之前做一些准备性的工作
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                // doNothing
            }
            synchronized(LazyModeDemo.class) {
                lazyModeDemo = new LazyModSynchronizedDemo();
            }
        }
        return lazyModeDemo;
    }
}
```
仔细看会发现这段代码仍然是线程不安全的。多线程下，else 判断中仍然无法解决得到同一个实例对象的结果。最终解决就需要提到著名的 DCL 机制(Dubbo-Check)

