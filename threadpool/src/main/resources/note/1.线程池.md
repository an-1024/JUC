# 线程池
## 背景:
随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：
ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务
## 线程池是什么:
线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。
## 作用:
线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并
发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。
## 带来的好处
1. 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 
2. 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 
3. 提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。 
4. 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。
## 解决的实际问题:
线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：

1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。
4. 为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。

Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。

在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：

1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。
在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。

(以上内容来自: [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html))

# Executor 和 Service

首先来看下类图:
![](../photo/1.Executor类图.png)
1. Executor: 线程池顶级接口;
2. ExecutorService: 线程池次级接口，对 Executor 做了一些扩展，增加一些功能;
3. ScheduledExecutorService: 对 ExecutorService 做了一些扩展，增加一些定时任务相关的功能;
4. AbstractExecutorService: 抽象类, 运用模板方法设计模式实现了一部分方法;
5. ThreadPoolExecutor: 普通线程池类, 包含最基本的一些线程池操作相关的方法实现;
6. ScheduledThreadPoolExecutor: 定时任务线程池类,用于实现定时任务相关功能;
7. ForkJoinPool: 新线程池类, java7中新增的线程池类, 基于工作窃取理论实现, 用于大任务拆小任务, 任务比较多的场景;
8. Executors: 线程池工具类, 定义了一些快速实现线程池的方法;

## Executor

线程池顶级接口, 定义一个无返回值任务的方法。源码定义如下:
```java
public interface Executor {

    /**
     * 执行无返回任务
     * 根据 Executor 的实现判断, 可能是在新线程、线程池、线程调用中执行
     * 抽象线程的会执行的动作
     */
    void execute(Runnable command);
}
```

## ExecutorService
线程池次级接口，对 Executor 做了一些扩展，增加一些功能; 介绍一些线程常用的操作即动作方法; 当我们将 ExecutorService 拆分为
Executor + Service 就能更好的理解这个接口类的定义: 为 Executor 线程池提供 Service 服务的类。
摘取部分服务方法介绍:
```java
public interface ExecutorService extends Executor {
    /**
     * 关闭线程池, 不会立即关闭, 等待线程池中的任务执行完成
     */
    void shutdown();

    /**
     * 立即关闭线程池
     */
    List<Runnable> shutdownNow();

    /**
     * 判断线程池是否关闭
     */
    boolean isShutdown();

    /**
     * 执行有返回值的任务, 通过 Future.get() 获取返回值
     */
    <T> Future<T> submit(Callable<T> task);

    /**
     * 在超时时间内返回任意一个已完成任务的执行结果, 未执行完成的任务将被取消
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;

    /**
     * 任意一个已完成任务的执行结果, 未执行完成的任务将被取消
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
            throws InterruptedException, ExecutionException;

    /**
     * 在超时时间内返回所有给定任务的执行结果
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
            throws InterruptedException;

    /**
     * 返回给定任务集合的结果
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
            throws InterruptedException;
}
```

## AbstractExecutorService
抽象类, 运用模板方法设计模式实现了一部分方法; 拆分解释: Abstract + Executor + Service 定义为: 将线程池中的服务方法具体会做什么通用的操作
再次进行抽象剥离;
```java
public abstract class AbstractExecutorService implements ExecutorService {
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        // 将创建的任务封装到 RunnableFuture 类中, 可以看到这是一个无返回值的任务 void
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        // 执行 task 任务
        execute(ftask);
        return ftask;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public <T> Future<T> submit(Runnable task, T result) {
        // 有返回值的任务封装创建
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        // 执行 task 任务
        execute(ftask);
        return ftask;
    }
    
    
}
```
newTaskFor(task, result) 创建了一个 new FutureTask<T>(runnable, value)。FutureTask 继承了 RunnableFuture, RunnableFuture 继承了
Runnable, Future<V>, 这个接口整合了 Runnable 和 Future 动作。具体的实现在 FutureTask 中。
```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * 作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果。 
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

这也就表明了 newTaskFor(task, result);  RunnableFuture 被具象成一个 FutureTask 对象。那么 FutureTask 必然是实现了 RunnableFuture
的接口类。该类定义如下:
```java
public class FutureTask<V> implements RunnableFuture<V> {
    
}
```

再回到最初的地方: AbstractExecutorService 类, 来看下其公共的逻辑方法:
```java
public abstract class AbstractExecutorService implements ExecutorService {
    // 没有超时时间
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
            throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        // 保存 Future 返回结果
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks) {
                // 封装 task 对象
                RunnableFuture<T> f = newTaskFor(t);
                // 将需要执行的 FutureTask 放入返回结果集合中
                futures.add(f);
                // 放入线程池中执行
                execute(f);
            }
            // 循环结果集合通过 FutureTask.get 获取结果
            for (int i = 0, size = futures.size(); i < size; i++) {
                Future<T> f = futures.get(i);
                if (!f.isDone()) {
                    try {
                        // 阻塞获取结果只
                        f.get();
                        // 忽略了取消执行异常
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                // 取消执行
                for (int i = 0, size = futures.size(); i < size; i++)
                    futures.get(i).cancel(true);
        }
    }
    
    // 有设置超时时间
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                         long timeout, TimeUnit unit)
            throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        // 将超时时间转换为 纳秒
        long nanos = unit.toNanos(timeout);
        // 添加到返回结果集合中
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            // 先将所有的 task 任务添加到集合中
            for (Callable<T> t : tasks)
                futures.add(newTaskFor(t));
            // 然后再计算结束时间，这样计算时间会比较精准
            final long deadline = System.nanoTime() + nanos;
            final int size = futures.size();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            for (int i = 0; i < size; i++) {
                // 开始放入线程池中执行
                execute((Runnable)futures.get(i));
                // 计算执行是否超时
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L)
                    // 当超时立刻返回, 结束循环, 这就存在返回结果集中存在
                    // 没有执行完成的任务
                    return futures;
            }

            for (int i = 0; i < size; i++) {
                Future<T> f = futures.get(i);
                if (!f.isDone()) {
                    // 同样当获取结果超时会导致结果集中存在没有
                    // 获取到结果的 FutureTask
                    if (nanos <= 0L)
                        return futures;
                    try {
                        // 阻塞获取结果超时时间
                        f.get(nanos, TimeUnit.NANOSECONDS);
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    } catch (TimeoutException toe) {
                        return futures;
                    }
                    nanos = deadline - System.nanoTime();
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                // 超时取消执行任务
                for (int i = 0, size = futures.size(); i < size; i++)
                    futures.get(i).cancel(true);
        }
    }
    
    // 返回任意一个结果, 就结束线程池中所有线程
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
            throws InterruptedException, ExecutionException {
        try {
            return doInvokeAny(tasks, false, 0);
        } catch (TimeoutException cannotHappen) {
            assert false;
            return null;
        }
    }
    
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                           long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
        return doInvokeAny(tasks, true, unit.toNanos(timeout));
    }

    private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                              boolean timed, long nanos)
            throws InterruptedException, ExecutionException, TimeoutException {
        if (tasks == null)
            throw new NullPointerException();
        int ntasks = tasks.size();
        if (ntasks == 0)
            throw new IllegalArgumentException();
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(ntasks);
        ExecutorCompletionService<T> ecs =
                new ExecutorCompletionService<T>(this);

        try {
            // 将任务提交到了 ExecutorCompletionService
            futures.add(ecs.submit(it.next()));
            // 提交一个 task, 未执行的 task -1
            --ntasks;
            // 执行的线程 +1
            int active = 1;
            // 死循环
            for (;;) {
                // 获取结果
                Future<T> f = ecs.poll();
                // 没有获取到
                if (f == null) {
                    if (ntasks > 0) {
                        // 减去一个未执行任务
                        --ntasks;
                        // 将下一个任务放入
                        futures.add(ecs.submit(it.next()));
                        ++active;
                    }
                    else if (active == 0)
                        break;
                    else if (timed) {
                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                        if (f == null)
                            throw new TimeoutException();
                        nanos = deadline - System.nanoTime();
                    }
                    else
                        f = ecs.take();
                }
                if (f != null) {
                    --active;
                    try {
                        return f.get();
                    } catch (ExecutionException eex) {
                        ee = eex;
                    } catch (RuntimeException rex) {
                        ee = new ExecutionException(rex);
                    }
                }
            }

            if (ee == null)
                ee = new ExecutionException();
            throw ee;

        } finally {
            for (int i = 0, size = futures.size(); i < size; i++)
                futures.get(i).cancel(true);
        }
    }

}
```

### invokeAll 方法小结:
超时与不超时的方法导致流程一致, 区别是多了超时时间的判断。

1. 将 Runnable 封装为 FutureTask 对象；
2. 初始化 FutureTask 返回结果集;
3. 放入线程池中执行 execute();
4. 最后遍历结果集取消任务;


